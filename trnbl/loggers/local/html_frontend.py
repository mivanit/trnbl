import json


def get_html_frontend() -> str:
	return "<!DOCTYPE html>\n\n<html>\n<head>\n<title>trnbl dashboard</title>\n<!-- packages from the web -->\n<script src=\"https://cdn.plot.ly/plotly-latest.min.js\"></script>\n<script src=\"https://unpkg.com/interactjs/dist/interact.min.js\"></script>\n<!-- ag-grid -->\n<script src=\"https://cdn.jsdelivr.net/npm/ag-grid-community/dist/ag-grid-community.min.js\"></script>\n<!-- feather icons -->\n<script src=\"https://unpkg.com/feather-icons\"></script>\n<!-- dashboard js file -->\n\n<!-- custom css -->\n\n<!-- favicon -->\n\n<style>/* global font, and for plotly */\n* {\n\tfont-family: 'Roboto-mono', monospace;\n}\n\n/* same for any svg element */\nsvg {\n\tfont-family: 'Roboto-mono', monospace;\n}\n\n/* when hovering a draggable element */\n.draggable:hover {\n\tz-index: 999;\n\tborder: 1px solid blue;\n\ttransition-delay: 0.5s;\n}\n\n.draggable {\n\ttransition: z-index 0.5s;\n}\n\n.draggable:not(:hover) {\n\ttransition-delay: 0.5s;\n}\n\n\n/* Make sure the font-family matches the one provided by ag-Grid */\n.ag-icon {\n\tfont-family: \"agGridAlpine\" !important;\n}\n\noption {\n\tfont-size: 2em !important;\n\t/* why isnt this working? */\n}\n\n.rootContainer {\n\t/* display: flex; */\n\t/* width: 100%; */\n\theight: 100%;\n\t/* flex-direction: column; */\n\t/* flex-direction: row; */\n}\n\n.plotContainer {\n\tborder: 1px solid black;\n\tbackground-color: #f0f0f0;\n\tborder-radius: 10px;\n\tpadding: 3px;\n}\n\n.runsManifestBox {\n\tborder: 1px solid black;\n\tbackground-color: #f0f0f0;\n\tborder-radius: 10px;\n\tpadding: 3px;\n}\n\n.plotSettings {\n\t/* left margin */\n\tmargin-left: 2px;\n}\n\n.headerButton {\n\theight: 35px;\n\t/* Set the desired height for the buttons */\n\tfont-size: 16px;\n\tline-height: 30px;\n\tpadding: 0 10px;\n\tcursor: pointer;\n\tdisplay: inline-block;\n\tcolor: #000000;\n\tbackground-color: #d8d8d8;\n\tborder: 1px solid #3c3c3c;\n\tborder-radius: 5px;\n\ttext-align: center;\n\tfont-size: 16px;\n\ttransition: background-color 0.1s, border-color 0.1s, color 0.1s;\n}\n\n.headerButton:hover,\n.headerButton:focus {\n\tbackground-color: #797979;\n\tborder-color: #213244;\n\tcolor: #000000;\n}\n\n.headerButton svg {\n\t/* vertically centered svg */\n\tvertical-align: middle;\n}\n\nhr {\n\tmargin-top: 10px;\n\t/* Adjust the margin as needed */\n\tborder: none;\n\tborder-top: 1px solid #ccc;\n\t/* Set the desired color and style for the horizontal rule */\n}\n\n\n.axis-toggle-container {\n\tmargin-top: 10px;\n}\n\n/* .plot-div {\n\tmargin-bottom: 20px;\t\n}\n\n.plotContainer {\n\ttouch-action: none;\n\tbox-sizing: border-box;\n} */\n\n/* The switch - the box around the slider */\n.switch {\n\tposition: relative;\n\tdisplay: inline-block;\n\twidth: 3em;\n\theight: 1.5em;\n}\n\n/* Hide default HTML checkbox */\n.switch input {\n\topacity: 0;\n\twidth: 0;\n\theight: 0;\n}\n\n/* The slider */\n.slider {\n\tposition: absolute;\n\tcursor: pointer;\n\ttop: 0;\n\tleft: 0;\n\tright: 0;\n\tbottom: 0;\n\tbackground-color: #ccc;\n\t-webkit-transition: .4s;\n\ttransition: .4s;\n}\n\n.slider:before {\n\tposition: absolute;\n\tcontent: \"\";\n\theight: 1em;\n\twidth: 1em;\n\tleft: 4px;\n\tbottom: 4px;\n\tbackground-color: white;\n\t-webkit-transition: .4s;\n\ttransition: .4s;\n}\n\ninput:checked+.slider {\n\tbackground-color: #2196F3;\n}\n\ninput:focus+.slider {\n\tbox-shadow: 0 0 1px #2196F3;\n}\n\ninput:checked+.slider:before {\n\t-webkit-transform: translateX(1.5em);\n\t-ms-transform: translateX(1.5em);\n\ttransform: translateX(1.5em);\n}\n\n/* Rounded sliders */\n.slider.round {\n\tborder-radius: 34px;\n}\n\n.slider.round:before {\n\tborder-radius: 50%;\n}\n\n@keyframes blinkButton {\n    0% { background-color: #d8d8d8; }\n    50% { background-color: #b5d8c9; }\n    100% { background-color: #d8d8d8; }\n}\n\n.blink-border {\n    animation: blinkButton 0.5s ease-in-out;\n}</style><link href=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABAAgMAAADXB5lNAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAMUExURRwfKv////5MRBel/pJJVGsAAAAJcEhZcwAADsIAAA7CARUoSoAAAAFdSURBVDjLnZNNTsMwEEbHsSJBNmzaO0BO4Ta7riLR7llWPUUQFwnqxtzCYLFhw1V6BL7xT+zEFRK4alW/zPdstTP0v3WYlt/XCfS+oI+ltSsR+xReK8YqAcHF69zP1Su8q4FImrDZC0XNSHR3CeU9QKsDqNkDoFuOIIQTGFRjM0CDGgZHobAdoQFAtTgJhYCGBhEGu2cFZcuaamCwfd2O0jTQ4HQG6m03SFNBE8HDyd9Sh4i6PUrLd4DESbv3Jw8gCUB5AEkOrIFkASDxoLMMrIEkA3hBMgFrP14guUnANGdI7heg0bOINVUE7gwc3EaAp9bFIvg6e0AFoEVkAiz1JDv2N/D5iO/uwxoGh3xtroEUwU8yl2bAX6QA4RQlOuP6x35fKAL+b2eAG07Gm3rAkSDtXYQRmix0IXGXRkAeuC6Vpg6tneYj9Pu0VtfGoxigYsSKISzHtBjkvy2iH6CFB7azg+vPAAAAAElFTkSuQmCC\" rel=\"icon\"/><script>/*\n ######   #######  ##    ##  ######  ########  ######\n##    ## ##     ## ###   ## ##    ##    ##    ##    ##\n##       ##     ## ####  ## ##          ##    ##\n##       ##     ## ## ## ##  ######     ##     ######\n##       ##     ## ##  ####       ##    ##          ##\n##    ## ##     ## ##   ### ##    ##    ##    ##    ##\n ######   #######  ##    ##  ######     ##     ######\n*/\n\n// APIs and global variables\nlet LAYOUT_MANAGER = null;\nlet PLOTLY_LAYOUTS = {};\nlet GRID_API = null;\n// const xUnitsKeys = ['samples', 'batches', \"timestamp\"]; // TODO: read dynamically, add epochs & runs\nconst DEFAULT_XUNITS = 'samples';\n\n// settings\n\nconst LAYOUT_CONFIG = {\n\t\"plot_cont_height\": 300,\n\t\"plotcont_frac\": 0.4,\n\t\"elements_initial_offset_y\": 200,\n\t\"minimum_dims\": { width: 250, height: 150 },\n\t\"table_init_height\": 800,\n\t\"plot_bottom_margin_px\": 5,\n\t\"snap_interval_default\": 50,\n\t\"settings_width_px\": 100,\n}\n\nconst NOTIFICATION_CONFIG = {\n\tcolors: {\n\t\t'info': 'lightgreen',\n\t\t'warning': 'lightyellow',\n\t\t'error': 'lightcoral',\n\t},\n\tborder_colors: {\n\t\t'info': 'green',\n\t\t'warning': 'orange',\n\t\t'error': 'red',\n\t},\n\ttimeout: 5000,\n}\n\nconst AUTO_REFRESH_CONFIG = {\n\tinterval: -1,\n\tselect_options: [\n\t\t{ value: -1, label: 'Off' },\n\t\t{ value: 1, label: '1' },\n\t\t{ value: 5, label: '5' },\n\t\t{ value: 10, label: '10' },\n\t\t{ value: 30, label: '30' },\n\t\t{ value: 60, label: '60' },\n\t\t{ value: 100, label: '100' },\n\t\t{ value: 1000, label: '1000' }\n\t],\n}\n\nconst DEFAULT_AUTO_REFRESH = 10;\n\nconst DEFAULT_STYLE = {\n\tborder: '1px solid black',\n\tbackgroundColor: '#f0f0f0',\n\tborderRadius: '10px',\n\tpadding: '3px',\n}\nconst PLOTLY_LAYOUT_MARGIN = { l: 40, r: 30, b: 40, t: 50, pad: 0 };\n\n\n/*\n####  #######     ##     ## ##    ##  ######\n ##  ##     ##    ###   ### ###   ## ##    ##\n ##  ##     ##    #### #### ####  ## ##\n ##  ##     ##    ## ### ## ## ## ## ##   ####\n ##  ##     ##    ##     ## ##  #### ##    ##\n ##  ##     ##    ##     ## ##   ### ##    ##\n####  #######     ##     ## ##    ##  ######\n*/\n\nclass IOManager {\n\tconstructor() {\n\t\tthis.fileTimestamps = {};\n\t}\n\n\tasync fetchJson(path) {\n\t\ttry {\n\t\t\tconst response = await fetch(path);\n\t\t\tif (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n\t\t\treturn await response.json();\n\t\t} catch (error) {\n\t\t\tcreateNotification(`Fetch JSON error: ${error}`, 'error', error);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tasync fetchJsonLines(path, notify_last_line_error = false) {\n\t\ttry {\n\t\t\tconst response = await fetch(path);\n\t\t\tif (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n\t\t\tconst text = await response.text();\n\t\t\tconst lines = text.trim().split('\\n');\n\t\t\tconst validLines = lines.slice(0, -1).map(line => JSON.parse(line));\n\n\t\t\t// Try parsing the last line\n\t\t\ttry {\n\t\t\t\tconst lastLine = JSON.parse(lines[lines.length - 1]);\n\t\t\t\tvalidLines.push(lastLine);\n\t\t\t} catch (error) {\n\t\t\t\tif (notify_last_line_error) {\n\t\t\t\t\tcreateNotification(`Invalid JSON in the last line of ${path}: ${error}`, 'error', error);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn validLines;\n\t\t} catch (error) {\n\t\t\tcreateNotification(`Fetch JSON Lines error: ${error}`, 'error', error);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tasync saveJsonLocal(name, data) {\n\t\tconst data_json = JSON.stringify(data);\n\t\tlocalStorage.setItem(name, btoa(data_json));\n\t}\n\n\tasync readJsonLocal(name) {\n\t\tconst data_encoded = localStorage.getItem(name);\n\t\tif (data_encoded) {\n\t\t\tconst data_json = atob(data_encoded);\n\t\t\treturn JSON.parse(data_json);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tasync deleteJsonLocal(name) {\n\t\tlocalStorage.removeItem(name);\n\t}\n\n\tasync getFileModificationTime(path) {\n\t\ttry {\n\t\t\tconst response = await fetch(path, { method: 'HEAD' });\n\t\t\tif (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n\t\t\treturn new Date(response.headers.get('Last-Modified'));\n\t\t} catch (error) {\n\t\t\tcreateNotification(`Error fetching file modification time: ${error}`, 'error', error);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tasync fetchJsonIfModified(path) {\n\t\tconst lastModified = await this.getFileModificationTime(path);\n\t\tif (!lastModified) return null;\n\n\t\tif (!this.fileTimestamps[path] || lastModified > this.fileTimestamps[path]) {\n\t\t\tconst data = await this.fetchJson(path);\n\t\t\tif (data !== null) {\n\t\t\t\tthis.fileTimestamps[path] = lastModified;\n\t\t\t}\n\t\t\treturn data;\n\t\t}\n\t\treturn null; // File not modified\n\t}\n\n\tasync fetchJsonLinesIfModified(path) {\n\t\tconst lastModified = await this.getFileModificationTime(path);\n\t\tif (!lastModified) return null;\n\n\t\tif (!this.fileTimestamps[path] || lastModified > this.fileTimestamps[path]) {\n\t\t\tconst data = await this.fetchJsonLines(path);\n\t\t\tif (data !== null) {\n\t\t\t\tthis.fileTimestamps[path] = lastModified;\n\t\t\t}\n\t\t\treturn data;\n\t\t}\n\t\treturn null; // File not modified\n\t}\n}\n\nconst IO_MANAGER = new IOManager();\n\n\n/*\n########  ##     ## ##    ##    ########     ###    ########    ###\n##     ## ##     ## ###   ##    ##     ##   ## ##      ##      ## ##\n##     ## ##     ## ####  ##    ##     ##  ##   ##     ##     ##   ##\n########  ##     ## ## ## ##    ##     ## ##     ##    ##    ##     ##\n##   ##   ##     ## ##  ####    ##     ## #########    ##    #########\n##    ##  ##     ## ##   ###    ##     ## ##     ##    ##    ##     ##\n##     ##  #######  ##    ##    ########  ##     ##    ##    ##     ##\n*/\n\nclass RunData {\n\tconstructor(path) {\n\t\tthis.path = path;\n\t\tthis.config = null;\n\t\tthis.meta = null;\n\t\tthis.metrics = null;\n\t\tthis.logs = null;\n\t\tthis.artifacts = null;\n\t}\n\n\tasync loadData() {\n\t\tthis.config = await IO_MANAGER.fetchJson(`${this.path}/config.json`);\n\t\tthis.meta = await IO_MANAGER.fetchJson(`${this.path}/meta.json`);\n\t\tthis.metrics = await IO_MANAGER.fetchJsonLines(`${this.path}/metrics.jsonl`);\n\t\tthis.logs = await IO_MANAGER.fetchJsonLines(`${this.path}/log.jsonl`);\n\t\tthis.artifacts = await IO_MANAGER.fetchJsonLines(`${this.path}/artifacts.jsonl`);\n\t}\n\n\tpairMetrics(xKey, yKey) {\n\t\tconst xVals = [];\n\t\tconst yVals = [];\n\t\tif (this.metrics) {\n\t\t\tthis.metrics.forEach(metric => {\n\t\t\t\tconst xv = metric[xKey];\n\t\t\t\tconst yv = metric[yKey];\n\t\t\t\tif (!isNaN(xv) && !isNaN(yv)) {\n\t\t\t\t\txVals.push(xv);\n\t\t\t\t\tyVals.push(yv);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn [xVals, yVals];\n\t}\n\n\tstatic smoothData(data, span = null, method = 'SMA') {\n\t\tif (data.some(isNaN)) {\n\t\t\tcreateNotification('Data contains NaN values', 'warning');\n\t\t}\n\n\t\tif (!span) {\n\t\t\treturn data;\n\t\t}\n\n\t\tconst smoothed = [];\n\t\tswitch (method) {\n\t\t\tcase 'SMA':\n\t\t\t\tfor (let i = 0; i < data.length; i++) {\n\t\t\t\t\tconst start = Math.max(0, i - span + 1);\n\t\t\t\t\tconst window = data.slice(start, i + 1);\n\t\t\t\t\tconst sum = window.reduce((acc, val) => acc + val, 0);\n\t\t\t\t\tconst avg = sum / window.length;\n\t\t\t\t\tsmoothed.push(avg);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'EMA':\n\t\t\t\tlet ema = data[0]; // Starting with the first data point\n\t\t\t\tconst alpha = 2 / (span + 1);\n\t\t\t\tfor (let i = 0; i < data.length; i++) {\n\t\t\t\t\tema = alpha * data[i] + (1 - alpha) * (i > 0 ? ema : data[i]);\n\t\t\t\t\tsmoothed.push(ema);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'Gaussian':\n\t\t\t\t// Gaussian smoothing requires calculating weights for each point in the window\n\t\t\t\t// We'll use a simplified Gaussian kernel for demonstration purposes\n\t\t\t\tfor (let i = 0; i < data.length; i++) {\n\t\t\t\t\tlet weightedSum = 0;\n\t\t\t\t\tlet weightSum = 0;\n\t\t\t\t\tfor (let j = -span; j <= span; j++) {\n\t\t\t\t\t\tif (i + j >= 0 && i + j < data.length) {\n\t\t\t\t\t\t\t// Calculate the Gaussian weight\n\t\t\t\t\t\t\tconst weight = Math.exp(-(j * j) / (2 * span * span));\n\t\t\t\t\t\t\tweightedSum += data[i + j] * weight;\n\t\t\t\t\t\t\tweightSum += weight;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tconst gaussianAverage = weightedSum / weightSum;\n\t\t\t\t\tsmoothed.push(gaussianAverage);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcreateNotification(`Invalid smoothing method: ${method}`, 'error');\n\t\t\t\treturn [];\n\t\t}\n\n\t\treturn smoothed;\n\t}\n}\n\n/*\n########     ###    ########    ###       ##     ## ##    ##  ######\n##     ##   ## ##      ##      ## ##      ###   ### ###   ## ##    ##\n##     ##  ##   ##     ##     ##   ##     #### #### ####  ## ##\n##     ## ##     ##    ##    ##     ##    ## ### ## ## ## ## ##   ####\n##     ## #########    ##    #########    ##     ## ##  #### ##    ##\n##     ## ##     ##    ##    ##     ##    ##     ## ##   ### ##    ##\n########  ##     ##    ##    ##     ##    ##     ## ##    ##  ######\n*/\n\nclass DataManager {\n\tconstructor() {\n\t\tthis.manifest = null;\n\t\tthis.allRuns = {};\n\t\tthis.metricNames = new Set();\n\t\tthis.projectName = null;\n\t\tthis.summaryManifest = null;\n\t\tthis.lastRefreshTime = null;\n\t\tthis.updatedRuns = new Set();\n\t}\n\n\tasync loadManifest() {\n\t\t// load data\n\t\tthis.manifest = await IO_MANAGER.fetchJsonLines('runs.jsonl');\n\t\tif (!this.manifest) {\n\t\t\tcreateNotification('Failed to load manifest', 'error');\n\t\t}\n\n\t\t// get project name, metric names\n\t\tconst projectNames = new Set();\n\t\tfor (const run of this.manifest) {\n\t\t\tprojectNames.add(run.project);\n\n\t\t\trun.metric_names.forEach(metricName => {\n\t\t\t\tthis.metricNames.add(metricName);\n\t\t\t});\n\t\t}\n\t\t// project names should match\n\t\tif (projectNames.size === 1) {\n\t\t\tthis.projectName = projectNames.values().next().value;\n\t\t} else {\n\t\t\tcreateNotification(`Project names are not consistent across runs: ${projectNames}`, 'error');\n\t\t}\n\t}\n\n\tasync loadRuns() {\n\t\t// load manifest if not already loaded\n\t\tif (!this.manifest) {\n\t\t\tthis.loadManifest();\n\t\t}\n\n\t\t// load each run\n\t\tfor (const run of this.manifest) {\n\t\t\tconst runData = new RunData(`runs/${run.run_id}`);\n\t\t\tawait runData.loadData();\n\t\t\tthis.allRuns[run.run_id] = runData;\n\t\t}\n\n\t\t// update summary manifest (final metrics, timestamps, etc)\n\t\tthis.updateSummaryManifest();\n\t}\n\n\tupdateSummaryManifest() {\n\t\t// make sure there are runs\n\t\ttry {\n\t\t\tif (Object.keys(this.allRuns).length === 0) {\n\t\t\t\tthrow 'No runs found';\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tcreateNotification(`Could not find any runs to update summary manifest: ${error}`, 'error');\n\t\t}\n\n\t\t// create the summary manifest dictionary\n\t\tthis.summaryManifest = Object.values(this.allRuns).map(run => {\n\t\t\t// final timestamp, from logs\n\t\t\tconst finalTimestamp = run.logs.length > 0 ? run.logs[run.logs.length - 1].timestamp : null;\n\n\t\t\t// final values for each metric\n\t\t\tlet finalMetrics = {};\n\t\t\t// Iterate over the metrics array in reverse to find the last value for each metricName\n\t\t\tfor (let i = run.metrics.length - 1; i >= 0; i--) {\n\t\t\t\tthis.metricNames.forEach(metricName => {\n\t\t\t\t\t// Check if the metric name is present in the current metric and hasn't been added to lastValues yet\n\t\t\t\t\tif (run.metrics[i][metricName] !== undefined && finalMetrics[metricName] === undefined) {\n\t\t\t\t\t\tfinalMetrics[metricName] = run.metrics[i][metricName];\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// return the summary manifest object, for each run\n\t\t\treturn {\n\t\t\t\tid: {\n\t\t\t\t\tsyllabic: run.meta.syllabic_id,\n\t\t\t\t\trun: run.meta.run_id,\n\t\t\t\t},\n\t\t\t\ttiming: {\n\t\t\t\t\tstart: run.meta.run_init_timestamp,\n\t\t\t\t\tfinal: finalTimestamp,\n\t\t\t\t\tduration: new Date(finalTimestamp) - new Date(run.meta.run_init_timestamp),\n\t\t\t\t},\n\t\t\t\tfinal_metrics: finalMetrics,\n\t\t\t\tconfig: run.config,\n\t\t\t};\n\t\t});\n\t}\n\n\tasync refreshData(verbose = true) {\n\t\t\n\t\tif (verbose) {\n\t\t\tcreateNotification('Checking for data updates...', 'info');\n\t\t}\n\n\t\tlet dataUpdated = false;\n\t\tthis.updatedRuns.clear(); // Clear the set at the start of each refresh\n\n\t\t// Refresh manifest\n\t\tconst newManifest = await IO_MANAGER.fetchJsonLinesIfModified('runs.jsonl');\n\t\tif (newManifest) {\n\t\t\tthis.manifest = newManifest;\n\t\t\tdataUpdated = true;\n\t\t\tcreateNotification(\"Manifest file updated\", \"info\");\n\t\t}\n\n\t\t// Refresh run data\n\t\tfor (const run of this.manifest) {\n\t\t\tconst runPath = `runs/${run.run_id}`;\n\t\t\tconst newConfig = await IO_MANAGER.fetchJsonIfModified(`${runPath}/config.json`);\n\t\t\tconst newMeta = await IO_MANAGER.fetchJsonIfModified(`${runPath}/meta.json`);\n\t\t\tconst newMetrics = await IO_MANAGER.fetchJsonLinesIfModified(`${runPath}/metrics.jsonl`);\n\t\t\tconst newLogs = await IO_MANAGER.fetchJsonLinesIfModified(`${runPath}/log.jsonl`);\n\t\t\tconst newArtifacts = await IO_MANAGER.fetchJsonLinesIfModified(`${runPath}/artifacts.jsonl`);\n\n\t\t\tif (newConfig || newMeta || newMetrics || newLogs || newArtifacts) {\n\t\t\t\tconst runData = this.allRuns[run.run_id] || new RunData(runPath);\n\t\t\t\tif (newConfig) runData.config = newConfig;\n\t\t\t\tif (newMeta) runData.meta = newMeta;\n\t\t\t\tif (newMetrics) runData.metrics = newMetrics;\n\t\t\t\tif (newLogs) runData.logs = newLogs;\n\t\t\t\tif (newArtifacts) runData.artifacts = newArtifacts;\n\t\t\t\tthis.allRuns[run.run_id] = runData;\n\t\t\t\tdataUpdated = true;\n\t\t\t\tthis.updatedRuns.add(run.run_id);\n\t\t\t\tconsole.log(`Updated data for run ${run.run_id}`);\n\t\t\t}\n\t\t}\n\n\t\tif (dataUpdated) {\n\t\t\t// Update metric names\n\t\t\tthis.metricNames.clear();\n\t\t\tfor (const run of this.manifest) {\n\t\t\t\trun.metric_names.forEach(metricName => {\n\t\t\t\t\tthis.metricNames.add(metricName);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Update summary manifest\n\t\t\tthis.updateSummaryManifest();\n\n\t\t\tthis.lastRefreshTime = new Date();\n\t\t\t\n\t\t\tconst updatedRunsInfo = DATA_MANAGER.getUpdatedRunsInfo();\n\n\t\t\t// Update plots\n\t\t\tawait PLOT_MANAGER.populateAllPlots();\n\n\t\t\t// Update table\n\t\t\tGRID_API.setGridOption('rowData', DATA_MANAGER.summaryManifest);\n\t\t\tGRID_API.refreshCells({force: true});\n\n\t\t\t// Detailed notification\n\t\t\tif (updatedRunsInfo.count > 0) {\n\t\t\t\tcreateNotification(\n\t\t\t\t\t(\n\t\t\t\t\t\t`Data refreshed successfully. ${updatedRunsInfo.count} run(s) updated`\n\t\t\t\t\t\t// use ternary operator to add the list of updated runs if there are less than 3\n\t\t\t\t\t\t+ (updatedRunsInfo.count < 3 ? `: ${updatedRunsInfo.runs.join(', ')}` : '')\n\t\t\t\t\t),\n\t\t\t\t\t'info',\n\t\t\t\t\tupdatedRunsInfo,\n\t\t\t\t\tverbose,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tcreateNotification(\n\t\t\t\t\t'Manifest updated, but no individual runs were changed',\n\t\t\t\t\t'info',\n\t\t\t\t\tupdatedRunsInfo, verbose,\n\t\t\t\t);\n\t\t\t}\n\n\t\t} else {\n\t\t\tcreateNotification(\n\t\t\t\t'No new data updates found', 'info',\n\t\t\t\tnull, verbose,\n\t\t\t);\n\t\t}\n\n\t\treturn dataUpdated;\n\t}\t\n\n    initAutoRefresh() {\n        const autoRefreshSelect = document.getElementById('autoRefreshSelect');\n        \n        // Populate the select element with options\n        AUTO_REFRESH_CONFIG.select_options.forEach(option => {\n            const optionElement = document.createElement('option');\n            optionElement.value = option.value;\n            optionElement.textContent = option.label;\n            if (option.value === AUTO_REFRESH_CONFIG.interval) {\n                optionElement.selected = true;\n            }\n            autoRefreshSelect.appendChild(optionElement);\n        });\n\n        autoRefreshSelect.addEventListener('change', () => {\n            this.setAutoRefresh(parseFloat(autoRefreshSelect.value));\n        });\n\n        // Initialize auto-refresh with default value\n        this.setAutoRefresh(AUTO_REFRESH_CONFIG.interval);\n    }\n\n    setAutoRefresh(seconds) {\n        // Clear existing interval if any\n        if (this.autoRefreshInterval) {\n            clearInterval(this.autoRefreshInterval);\n        }\n\n        // If seconds is greater than 0, set new interval\n        if (seconds > 0) {\n            this.autoRefreshInterval = setInterval(\n\t\t\t\t() => {\n\t\t\t\t\tthis.refreshData(false).then(() => {\n\t\t\t\t\t\t// Blink the refresh button after each refresh\n\t\t\t\t\t\tblinkElement('autoRefreshButton');\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\tseconds * 1000,\n\t\t\t);\n            createNotification(`Auto refresh set to ${seconds} seconds`, 'info');\n        } else {\n            createNotification('Auto refresh turned off', 'info');\n        }\n    }\n\n\tgetUpdatedRunsInfo() {\n\t\treturn {\n\t\t\tcount: this.updatedRuns.size,\n\t\t\truns: Array.from(this.updatedRuns)\n\t\t};\n\t}\n}\n\nconst DATA_MANAGER = new DataManager();\n\n\n\n\n/*\n##          ###    ##    ##  #######  ##     ## ########\n##         ## ##    ##  ##  ##     ## ##     ##    ##\n##        ##   ##    ####   ##     ## ##     ##    ##\n##       ##     ##    ##    ##     ## ##     ##    ##\n##       #########    ##    ##     ## ##     ##    ##\n##       ##     ##    ##    ##     ## ##     ##    ##\n######## ##     ##    ##     #######   #######     ##\n*/\n\nclass LayoutManager {\n\tconstructor(projectName) {\n\t\tthis.projectName = projectName;\n\t\tthis.layout = {};\n\t\tthis.do_snap = true;\n\t\tthis.snapInterval = LAYOUT_CONFIG.snap_interval_default;\n\t\tthis.plot_configs = {};\n\t\tthis.grid_state = null;\n\t\tthis.visibilityState = {};\n\t\t// default layout stuff\n\t\tthis.init_y = this.round_to_snap_interval(LAYOUT_CONFIG.elements_initial_offset_y);\n\t\tthis.default_plot_cont_height = this.round_to_snap_interval(LAYOUT_CONFIG.plot_cont_height);\n\t\t// calculate widths\n\t\tconst window_width = window.innerWidth;\n\t\tthis.default_plot_cont_width = this.round_to_snap_interval(window_width * LAYOUT_CONFIG.plotcont_frac);\n\t\tthis.table_width = this.round_to_snap_interval(window_width - (this.default_plot_cont_width + this.snapInterval));\n\t}\n\n\tround_to_snap_interval(value) {\n\t\treturn Math.ceil(value / this.snapInterval) * this.snapInterval;\n\t}\n\n\tget_default_layout(\n\t\tplot_names,\n\t\tupdate_to_default = true,\n\t) {\n\t\t// convert plot_names to list\n\t\tconst plot_names_arr = Array.from(plot_names);\n\n\t\t// init layout\n\t\tvar layout = {};\n\t\tconst plot_y_step = this.round_to_snap_interval(this.default_plot_cont_height * 1.1)\n\n\t\t// plot containers\n\t\tfor (let i = 0; i < plot_names_arr.length; i++) {\n\t\t\tconst metricName = plot_names_arr[i];\n\t\t\tlayout[`plotContainer-${metricName}`] = {\n\t\t\t\tx: 0,\n\t\t\t\ty: this.init_y + i * plot_y_step,\n\t\t\t\theight: this.default_plot_cont_height,\n\t\t\t\twidth: this.default_plot_cont_width,\n\t\t\t};\n\t\t};\n\n\t\t// table\n\t\tlayout['runsManifest'] = {\n\t\t\tx: this.default_plot_cont_width + LAYOUT_CONFIG.snap_interval_default,\n\t\t\ty: this.init_y,\n\t\t\theight: LAYOUT_CONFIG.table_init_height,\n\t\t\twidth: this.table_width,\n\t\t};\n\n\t\t// write to global\n\t\tif (update_to_default) {\n\t\t\tthis.layout = layout;\n\t\t}\n\n\t\treturn layout;\n\t}\n\n\tasync getDefaultPlotConfig() {\n\t\treturn {\n\t\t\tsize: { width: this.default_plot_cont_width - LAYOUT_CONFIG.settings_width_px, height: this.default_plot_cont_height },\n\t\t\taxisScales: { x: 'linear', y: 'linear' },\n\t\t\tsmoothing_method: 'SMA',\n\t\t\tsmoothing_span: null,\n\t\t\txUnits: DEFAULT_XUNITS,\n\t\t};\n\t}\n\n\tasync getPlotConfig(metricName) {\n\t\tif (!(metricName in this.plot_configs)) {\n\t\t\tthis.plot_configs[metricName] = await this.getDefaultPlotConfig();\n\t\t}\n\t\treturn this.plot_configs[metricName];\n\t}\n\n\tmakeElementDraggable(element) {\n\t\t// get id and position\n\t\tconst id = element.id;\n\t\tlet position = this.getInitialPosition(element);\n\n\t\t// add .draggable class if its not there\n\t\tif (!element.classList.contains('draggable')) {\n\t\t\telement.classList.add('draggable');\n\t\t}\n\n\t\t// make draggable and resizable\n\t\tthis.initializeDragInteraction(element, position);\n\t\tthis.initializeResizeInteraction(element, position);\n\n\t\t// update layout\n\t\tthis.updateElementLayout(element, position.x, position.y, true);\n\t}\n\n\tgetInitialPosition(element) {\n\t\tconst id = element.id;\n\t\tif (this.layout[id]) {\n\t\t\treturn { x: this.layout[id].x, y: this.layout[id].y };\n\t\t} else {\n\t\t\treturn {\n\t\t\t\tx: parseFloat(element.getAttribute('data-x')) || 0,\n\t\t\t\ty: parseFloat(element.getAttribute('data-y')) || 0,\n\t\t\t};\n\t\t}\n\t}\n\n\tinitializeDragInteraction(element, position) {\n\t\tinteract(element).draggable({\n\t\t\tignoreFrom: '.draglayer, .ag-header, .ag-center-cols-container, .no-drag, .legend, .bg, .scrollbox',\n\t\t\tmodifiers: [\n\t\t\t\tinteract.modifiers.snap({\n\t\t\t\t\ttargets: [interact.snappers.grid({ x: this.snapInterval, y: this.snapInterval })],\n\t\t\t\t\trange: Infinity,\n\t\t\t\t\trelativePoints: [{ x: 0, y: 0 }]\n\t\t\t\t}),\n\t\t\t\tinteract.modifiers.restrict({\n\t\t\t\t\trestriction: 'parent',\n\t\t\t\t\telementRect: { top: 0, left: 0, bottom: 1, right: 1 },\n\t\t\t\t\tendOnly: true\n\t\t\t\t})\n\t\t\t],\n\t\t\tinertia: true\n\t\t}).on('dragmove', (event) => {\n\t\t\tposition.x += event.dx;\n\t\t\tposition.y += event.dy;\n\n\t\t\tthis.updateElementLayout(event.target, position.x, position.y, true);\n\t\t});\n\t}\n\n\tinitializeResizeInteraction(element, position) {\n\t\tinteract(element).resizable({\n\t\t\tedges: { left: true, right: true, bottom: true, top: true },\n\t\t\tmodifiers: [\n\t\t\t\tinteract.modifiers.snapSize({\n\t\t\t\t\ttargets: [interact.snappers.grid({ width: this.snapInterval, height: this.snapInterval })],\n\t\t\t\t\trange: Infinity,\n\t\t\t\t}),\n\t\t\t\tinteract.modifiers.restrictSize({\n\t\t\t\t\tmin: LAYOUT_CONFIG.minimum_dims,\n\t\t\t\t}),\n\t\t\t],\n\t\t\tinertia: true\n\t\t}).on('resizemove', (event) => {\n\t\t\tconst { width, height } = event.rect;\n\t\t\tposition.x += event.deltaRect.left;\n\t\t\tposition.y += event.deltaRect.top;\n\n\t\t\tconst target = event.target;\n\t\t\tthis.updateElementLayout(target, position.x, position.y, false, width, height);\n\n\t\t\tconst isPlotContainer = target.classList.contains('plotContainer');\n\t\t\tif (isPlotContainer) {\n\t\t\t\t// Adjust sizes of plotDiv and plotSettings inside the container\n\t\t\t\tconst plotSettings = target.querySelector('.plotSettings');\n\t\t\t\tconst plotDiv = target.querySelector('.plotDiv');\n\n\t\t\t\t// Set plotSettings width and adjust plotDiv width\n\t\t\t\tvar plotDivWidth = event.rect.width - LAYOUT_CONFIG.settings_width_px;\n\t\t\t\tplotSettings.style.width = plotDivWidth;\n\n\t\t\t\t// Update plotDiv and Plotly plot size\n\t\t\t\tplotDiv.style.width = `${plotDivWidth}px`;\n\t\t\t\tplotDiv.style.height = `${event.rect.height}px`;\n\n\t\t\t\t// Now, instruct Plotly to resize the plot\n\t\t\t\tconst plotID = plotDiv.id;\n\t\t\t\tPlotly.relayout(plotID, {\n\t\t\t\t\twidth: plotDivWidth, // New width for the plot\n\t\t\t\t\theight: event.rect.height - LAYOUT_CONFIG.plot_bottom_margin_px, // New height for the plot\n\t\t\t\t});\n\n\t\t\t\t// save in plot configs\n\t\t\t\tconst metricName = plotID.split('-')[1];\n\t\t\t\tthis.plot_configs[metricName].size = { width: plotDivWidth, height: event.rect.height };\n\t\t\t\tPLOTLY_LAYOUTS[metricName].width = plotDivWidth;\n\t\t\t\tPLOTLY_LAYOUTS[metricName].height = event.rect.height - LAYOUT_CONFIG.plot_bottom_margin_px;\n\t\t\t}\n\t\t});\n\t}\n\n\tupdateElementLayout(element, x, y, updatePosition = true, width = null, height = null) {\n\t\t// update position if provided\n\t\tif (updatePosition) {\n\t\t\t// element.style.transform = `translate(${x}px, ${y}px)`;\n\t\t\t// element.setAttribute('data-x', x);\n\t\t\t// element.setAttribute('data-y', y);\n\t\t\telement.style.left = `${x}px`;\n\t\t\telement.style.top = `${y}px`;\n\t\t}\n\n\t\t// update width and height if provided\n\t\tif (width && height) {\n\t\t\telement.style.width = `${width}px`;\n\t\t\telement.style.height = `${height}px`;\n\t\t}\n\t\telse {\n\t\t\twidth = element.offsetWidth;\n\t\t\theight = element.offsetHeight;\n\t\t}\n\n\t\t// store in layout\n\t\tthis.layout[element.id] = {\n\t\t\tx: x,\n\t\t\ty: y,\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t};\n\t\t// console.log('Updated layout for:', element.id, this.layout[element.id]);\n\t}\n\n\tupdateAllLayouts() {\n\t\tfor (const id in this.layout) {\n\t\t\tconst new_layout = this.layout[id];\n\t\t\tconst element = document.getElementById(id);\n\t\t\t// console.log('Updating layout for: ', id, new_layout);\n\t\t\tconst position = this.getInitialPosition(element);\n\t\t\tthis.updateElementLayout(element, new_layout.x, new_layout.y, true, new_layout.width, new_layout.height);\n\t\t}\n\t}\n\n\tget_local_storage_key() {\n\t\treturn `${this.projectName}_layout`;\n\t}\n\n\tasync saveLayout() {\n\t\tthis.updateGridState();\n\t\tconst layoutKey = this.get_local_storage_key();\n\t\tIO_MANAGER.saveJsonLocal(layoutKey, this);\n\t\tconst layout_read = await IO_MANAGER.readJsonLocal(layoutKey);\n\t\tif (layout_read && (JSON.stringify(layout_read) == JSON.stringify(this))) {\n\t\t\tconsole.log('Layout saved:', layout_read);\n\t\t\tcreateNotification('Layout saved', 'info');\n\t\t} else {\n\t\t\tconsole.error('Layout not saved:', this, layout_read);\n\t\t\tcreateNotification('Layout not saved', 'error');\n\t\t}\n\t}\n\n\tasync loadLayout(do_update = true) {\n\t\tconst layoutKey = this.get_local_storage_key();\n\t\tconst savedLayout = await IO_MANAGER.readJsonLocal(layoutKey);\n\t\tif (savedLayout) {\n\t\t\tthis.projectName = savedLayout.projectName;\n\t\t\tthis.layout = savedLayout.layout;\n\t\t\tthis.do_snap = savedLayout.do_snap;\n\t\t\tthis.snapInterval = savedLayout.snapInterval;\n\t\t\tthis.plot_configs = savedLayout.plot_configs;\n\t\t\tthis.grid_state = savedLayout.grid_state;\n\t\t\tthis.visibilityState = savedLayout.visibilityState;\n\t\t} else {\n\t\t\tthis.layout = this.get_default_layout(DATA_MANAGER.metricNames);\n\t\t}\n\t\tconsole.log('Layout loaded:', this);\n\t\tif (do_update) {\n\t\t\tthis.updateAllLayouts();\n\t\t}\n\t}\n\n\tasync updateSnap(do_snap = true, snapInterval = LAYOUT_CONFIG.snap_interval_default) {\n\t\tthis.do_snap = do_snap;\n\t\tif (!do_snap) {\n\t\t\tsnapInterval = 1;\n\t\t}\n\t\tthis.snapInterval = snapInterval;\n\n\t\tconsole.log('Snap settings updated:', this.do_snap, this.snapInterval);\n\n\t\tfor (const id in this.layout) {\n\t\t\tconst element = document.getElementById(id);\n\t\t\tlet position = this.getInitialPosition(element);\n\n\t\t\tthis.initializeDragInteraction(element, position);\n\t\t\tthis.initializeResizeInteraction(element, position);\n\t\t}\n\t}\n\n\tupdateGridState() {\n\t\tthis.grid_state = GRID_API.getState();\n\t}\n}\n\n\n\n/*\n########  ##        #######  ########     ######  ########  ######\n##     ## ##       ##     ##    ##       ##    ## ##       ##    ##\n##     ## ##       ##     ##    ##       ##       ##       ##\n########  ##       ##     ##    ##       ##       ######   ##   ####\n##        ##       ##     ##    ##       ##       ##       ##    ##\n##        ##       ##     ##    ##       ##    ## ##       ##    ##\n##        ########  #######     ##        ######  ##        ######\n*/\n\nclass PlotManager {\n\tconstructor() {\n\t\tthis.plots = {}; // Keyed by metricName, values are objects with Plotly plot div ID and settings\n\t}\n\n\tasync createPlot(metricName) {\n\t\t// get ids\n\t\tconst plotContainer_id = `plotContainer-${metricName}`;\n\t\tconst plotDiv_id = `plot-${metricName}`;\n\t\tconst plotSettings_id = `plotSettings-${metricName}`;\n\n\t\t// config and layout\n\t\tconst plotConfig = await LAYOUT_MANAGER.getPlotConfig(metricName);\n\t\tconst layout = LAYOUT_MANAGER.layout[plotContainer_id];\n\n\t\tconst plotContainerHTML = `\n\t\t\t<div\n\t\t\t\tid=\"${plotContainer_id}\"\n\t\t\t\tclass=\"plotContainer\" \n\t\t\t\tstyle=\"margin-bottom: 10px; display: flex; flex-direction: row; position: absolute; width: ${layout.width}px; height: ${layout.height}px; left: ${layout.x}px; top: ${layout.y}px; ${DEFAULT_STYLE}\"\n\t\t\t>\n\t\t\t\t<div \n\t\t\t\t\tid=\"${plotDiv_id}\"\n\t\t\t\t\tclass=\"plotDiv\" \n\t\t\t\t\tstyle=\"width: ${layout.width - LAYOUT_CONFIG.settings_width_px}px; height: ${layout.height - LAYOUT_CONFIG.plot_bottom_margin_px}px;\"\n\t\t\t\t></div>\n\t\t\t\t<div \n\t\t\t\t\tid=\"${plotSettings_id}\"\n\t\t\t\t\tclass=\"plotSettings\" \n\t\t\t\t\tstyle=\"width: ${LAYOUT_CONFIG.settings_width_px}; flex-shrink: 0; flex-grow: 0;\"\n\t\t\t\t></div>\n\t\t\t</div>\n\t\t`;\n\n\t\t// Add plot container to the root div\n\t\tdocument.getElementById('rootContainerDiv').insertAdjacentHTML('beforeend', plotContainerHTML);\n\n\t\t// Store plot info for later reference\n\t\tthis.plots[metricName] = {\n\t\t\tplotID: plotDiv_id,\n\t\t\tcontainerID: plotContainer_id,\n\t\t\tsettingsID: plotSettings_id,\n\t\t};\n\n\t\t// Specify plot layout and create empty plot\n\t\tconst plotly_layout = {\n\t\t\ttitle: `${metricName} over ${plotConfig.xUnits}`,\n\t\t\tautosize: true,\n\t\t\txaxis: {\n\t\t\t\ttitle: plotConfig.xUnits,\n\t\t\t\ttype: plotConfig.axisScales.x,\n\t\t\t\tshowgrid: true,\n\t\t\t},\n\t\t\tyaxis: {\n\t\t\t\ttitle: metricName,\n\t\t\t\ttype: plotConfig.axisScales.y,\n\t\t\t\tshowgrid: true,\n\t\t\t},\n\t\t\tmargin: PLOTLY_LAYOUT_MARGIN,\n\t\t\twidth: layout.width - LAYOUT_CONFIG.settings_width_px,\n\t\t\theight: layout.height - LAYOUT_CONFIG.plot_bottom_margin_px,\n\t\t};\n\n\t\t// Store layout\n\t\tPLOTLY_LAYOUTS[metricName] = plotly_layout;\n\n\t\t// To newPlot, pass copy, don't reference\n\t\tPlotly.newPlot(plotDiv_id, [], JSON.parse(JSON.stringify(plotly_layout)));\n\n\t\t// Add settings menu items\n\t\tthis.createAxisToggles(metricName);\n\t\tthis.createSmoothingInput(metricName);\n\n\t\t// Make draggable\n\t\tLAYOUT_MANAGER.makeElementDraggable(document.getElementById(plotContainer_id));\n\t}\n\n\tasync createAllPlots(\n\t\torigin_x = 50,\n\t\torigin_y = 150,\n\t) {\n\t\tconst metrics = DATA_MANAGER.metricNames;\n\t\tlet n_metrics_counter = 0;\n\n\t\tmetrics.forEach(metricName => {\n\t\t\tn_metrics_counter += 1;\n\t\t\tconsole.log(`creating plot ${n_metrics_counter} for ${metricName}`);\n\t\t\tthis.createPlot(metricName);\n\t\t});\n\t}\n\n\tasync updatePlot(metricName) {\n\t\t// get and set settings & config\n\t\tconst plotInfo = this.plots[metricName];\n\t\tconst plotConfig = await LAYOUT_MANAGER.getPlotConfig(metricName);\n\t\tif (!plotInfo) {\n\t\t\tconsole.error(`Plot for metric ${metricName} not found.`);\n\t\t\treturn;\n\t\t}\n\n\t\t// get data\n\t\t// data manager will handle reloading the data, if necessary\n\t\tvar traces = [];\n\t\tfor (const runId in DATA_MANAGER.allRuns) {\n\t\t\tconst run = DATA_MANAGER.allRuns[runId];\n\t\t\tconst run_syllabic_id = run.meta.syllabic_id;\n\n\t\t\tconst [x_vals, y_vals] = run.pairMetrics(DEFAULT_XUNITS, metricName);\n\n\t\t\t// Apply smoothing based on the selected method and span\n\t\t\tlet smoothedYVals = RunData.smoothData(y_vals, plotConfig.smoothing_span, plotConfig.smoothing_method);\n\n\t\t\tconst trace = {\n\t\t\t\tx: x_vals,\n\t\t\t\ty: smoothedYVals,\n\t\t\t\tmode: 'lines',\n\t\t\t\tline: plotConfig.smoothing_span ? { shape: 'spline' } : {},\n\t\t\t\tname: run_syllabic_id,\n\t\t\t\tvisible: LAYOUT_MANAGER.visibilityState[run_syllabic_id] !== false ? true : 'legendonly',\n\t\t\t};\n\t\t\ttraces.push(trace);\n\t\t}\n\n\t\t// Update the layout properties\n\t\tPLOTLY_LAYOUTS[metricName].xaxis.type = plotConfig.axisScales.x;\n\t\tPLOTLY_LAYOUTS[metricName].yaxis.type = plotConfig.axisScales.y;\n\t\tPLOTLY_LAYOUTS[metricName].uirevision = metricName;\n\n\t\t// Update Plotly plot\n\t\tPlotly.react(\n\t\t\tplotInfo.plotID,\n\t\t\ttraces,\n\t\t\tJSON.parse(JSON.stringify(PLOTLY_LAYOUTS[metricName])),\n\t\t);\n\t}\n\n\tupdateTraceVisibility(runId, isVisible) {\n\t\tLAYOUT_MANAGER.visibilityState[runId] = isVisible;\n\t\tfor (const metricName of DATA_MANAGER.metricNames) {\n\t\t\tconst plotInfo = this.plots[metricName];\n\t\t\tif (plotInfo) {\n\t\t\t\tPlotly.restyle(\n\t\t\t\t\tplotInfo.plotID,\n\t\t\t\t\t{ visible: isVisible ? true : 'legendonly' },\n\t\t\t\t\t[this.getTraceIndex(plotInfo.plotID, runId)],\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tgetTraceIndex(plotId, runId) {\n\t\tconst plotDiv = document.getElementById(plotId);\n\t\tconst data = plotDiv.data;\n\t\tconst index = data.findIndex(trace => trace.name === runId);\n\t\tif (index < 0) {\n\t\t\tconsole.error(`Trace for run ${runId} not found in plot ${plotId}`);\n\t\t}\n\t\treturn index;\n\t}\n\n\tupdateAllVisibility() {\n\t\tfor (const metricName of DATA_MANAGER.metricNames) {\n\t\t\tthis.updatePlot(metricName);\n\t\t}\n\t}\n\n\tasync populateAllPlots() {\n\t\t// for each metric\n\t\tfor (const metricName of DATA_MANAGER.metricNames) {\n\t\t\tthis.updatePlot(metricName);\n\t\t}\n\t}\n\n\tupdateAxisScale(metricName, axis, scale) {\n\t\t// get plot info\n\t\tconst plotInfo = this.plots[metricName];\n\t\tif (!plotInfo) {\n\t\t\tconsole.error(`Plot for metric ${metricName} not found.`);\n\t\t\treturn;\n\t\t}\n\n\t\t// Update scale in settings\n\t\tconst plotConfig = LAYOUT_MANAGER.plot_configs[metricName];\n\t\tplotConfig.axisScales[axis] = scale;\n\n\t\t// Reflect change in Plotly plot\n\t\tPlotly.relayout(\n\t\t\tplotInfo.plotID,\n\t\t\t{\n\t\t\t\t[`${axis}axis`]: { type: scale },\n\t\t\t\tuirevision: metricName,\n\t\t\t},\n\t\t);\n\t}\n\n\n\tcreateAxisToggles(metricName) {\n\t\tconst plotSettingsId = this.plots[metricName].settingsID;\n\t\tconst plotDivId = this.plots[metricName].plotID;\n\t\tconst plotSettings = document.getElementById(plotSettingsId);\n\n\t\t['x', 'y'].forEach(axis => {\n\t\t\tconst toggleId = `${plotDivId}-${axis}Toggle`;\n\t\t\tconst toggleHtml = `\n\t\t\t\t<div class=\"axis-toggle-container\" style=\"display: block;\">\n\t\t\t\t\t<label for=\"${toggleId}\" style=\"display: block;\">${axis.toUpperCase()} Scale</label>\n\t\t\t\t\t<div style=\"display: flex; align-items: center;\">\n\t\t\t\t\t\t<i data-feather=\"arrow-up-right\">lin</i>\n\t\t\t\t\t\t<label class=\"switch\">\n\t\t\t\t\t\t\t<input type=\"checkbox\" id=\"${toggleId}\">\n\t\t\t\t\t\t\t<span class=\"slider round\"></span>\n\t\t\t\t\t\t</label>\n\t\t\t\t\t\t<i data-feather=\"corner-right-up\">log</i>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t`;\n\n\t\t\tconst toggleDiv = document.createElement('div');\n\t\t\ttoggleDiv.innerHTML = toggleHtml.trim();\n\t\t\tplotSettings.appendChild(toggleDiv);\n\n\t\t\tconst input = document.getElementById(toggleId);\n\t\t\tinput.checked = LAYOUT_MANAGER.plot_configs[metricName].axisScales[axis] === 'log';\n\t\t\tinput.onchange = () => {\n\t\t\t\tconst scale = input.checked ? 'log' : 'linear';\n\t\t\t\tthis.updateAxisScale(metricName, axis, scale);\n\t\t\t};\n\n\t\t});\n\t}\n\n\tasync createSmoothingInput(metricName) {\n\t\t// get the div ids\n\t\tconst plotDivId = this.plots[metricName].plotID;\n\t\tconst plotSettingsId = this.plots[metricName].settingsID;\n\n\t\t// Define the smoothing methods\n\t\tconst smoothingMethods = ['SMA', 'EMA', 'Gaussian'];\n\n\t\t// Create the HTML string for the smoothing input container\n\t\tconst smoothSettingHtml = `\n\t\t\t<div class=\"smoothing-input-container no-drag\" style=\"display: block; margin-top: 10px; border: 1px solid grey; border-radius: 3px;\">\n\t\t\t\t<label for=\"smoothingInput-${plotDivId}\" style=\"font-weight: bold;\">Smooth:</label><br>\n\t\t\t\t<label for=\"smoothingMethodSelect-${plotDivId}\">Method</label><br>\n\t\t\t\t<select class=\"no-drag\" id=\"smoothingMethodSelect-${plotDivId}\" style=\"width: 6em;\">\n\t\t\t\t\t${smoothingMethods.map(method => `<option value=\"${method}\">${method}</option>`).join('')}\n\t\t\t\t</select><br>\n\t\t\t\t<label for=\"smoothingInput-${plotDivId}\">Span</label><br>\n\t\t\t\t<input class=\"no-drag\" type=\"number\" min=\"0\" max=\"1000\" value=\"0\" id=\"smoothingInput-${plotDivId}\" style=\"width: 4.2em;\">\n\t\t\t</div>\n\t\t`;\n\n\t\t// Create a container for the smoothing input\n\t\tconst smoothSettingContainer = document.createElement('div');\n\t\tsmoothSettingContainer.innerHTML = smoothSettingHtml.trim();\n\n\t\t// Append the input container to the plot settings\n\t\tconst plotSettings = document.getElementById(plotSettingsId);\n\t\tplotSettings.appendChild(smoothSettingContainer);\n\n\t\t// Get references to the input elements\n\t\tconst spanInput = document.getElementById(`smoothingInput-${plotDivId}`);\n\t\tconst smoothingMethodSelect = document.getElementById(`smoothingMethodSelect-${plotDivId}`);\n\n\t\t// Set values to those from plot_configs\n\t\tspanInput.value = LAYOUT_MANAGER.plot_configs[metricName].smoothing_span;\n\t\tsmoothingMethodSelect.value = LAYOUT_MANAGER.plot_configs[metricName].smoothing_method;\n\n\t\t// On change, modify the plot config and call updatePlot\n\t\tspanInput.onchange = () => {\n\t\t\tLAYOUT_MANAGER.plot_configs[metricName].smoothing_span = parseInt(spanInput.value);\n\t\t\tthis.updatePlot(metricName);\n\t\t};\n\t\tsmoothingMethodSelect.onchange = () => {\n\t\t\tLAYOUT_MANAGER.plot_configs[metricName].smoothing_method = smoothingMethodSelect.value;\n\t\t\tthis.updatePlot(metricName); // Update the plot when smoothing method changes\n\t\t};\n\t}\n}\n\nlet PLOT_MANAGER = new PlotManager();\n\n\n\n/*\n##     ## ########    ###    ########  ######## ########\n##     ## ##         ## ##   ##     ## ##       ##     ##\n##     ## ##        ##   ##  ##     ## ##       ##     ##\n######### ######   ##     ## ##     ## ######   ########\n##     ## ##       ######### ##     ## ##       ##   ##\n##     ## ##       ##     ## ##     ## ##       ##    ##\n##     ## ######## ##     ## ########  ######## ##     ##\n*/\n\nasync function headerButtons() {\n\t// get the project name, set the header\n\tconst projectH1 = document.getElementById('projectH1');\n\tprojectH1.textContent = DATA_MANAGER.projectName + ' trnbl Dashboard';\n\tconst gridSnapCheckbox = document.getElementById('gridSnapCheckbox');\n\n\t// set up grid snap checkbox\n\tgridSnapCheckbox.checked = LAYOUT_MANAGER.do_snap;\n\tgridSnapCheckbox.addEventListener('change', function () {\n\t\tLAYOUT_MANAGER.updateSnap(gridSnapCheckbox.checked);\n\t});\n\n\t// save layout to local storage\n\tdocument.getElementById('saveLayoutButton').addEventListener(\n\t\t'click',\n\t\tasync () => {\n\t\t\tawait LAYOUT_MANAGER.saveLayout();\n\t\t}\n\t);\n\n\t// download layout as json\n\tdocument.getElementById('downloadLayoutButton').addEventListener(\n\t\t'click',\n\t\tasync () => {\n\t\t\tconst layoutKey = LAYOUT_MANAGER.get_local_storage_key();\n\t\t\tconst layout_json = JSON.stringify(LAYOUT_MANAGER, null, '\\t');\n\t\t\tconst blob = new Blob([layout_json], { type: 'application/json' });\n\t\t\tconst url = URL.createObjectURL(blob);\n\t\t\tconst a = document.createElement('a');\n\t\t\ta.href = url;\n\t\t\ta.download = layoutKey + '.json';\n\t\t\tdocument.body.appendChild(a);\n\t\t\ta.click();\n\t\t\ta.remove();\n\t\t\tURL.revokeObjectURL(url);\n\t\t}\n\t);\n\n\t// reset layout to default\n\tdocument.getElementById('resetLayoutButton').addEventListener(\n\t\t'click',\n\t\tasync () => {\n\t\t\t// delete\n\t\t\tconst layoutKey = LAYOUT_MANAGER.get_local_storage_key();\n\t\t\tIO_MANAGER.deleteJsonLocal(layoutKey);\n\t\t\t// reload page\n\t\t\tlocation.reload();\n\t\t\tcreateNotification('Layout resetting...', 'info');\n\t\t}\n\t);\n\n    // Set up manual refresh button\n    document.getElementById('refreshButton').addEventListener(\n        'click',\n        async () => {\n            await DATA_MANAGER.refreshData();\n        }\n    );\n\n\t// Set up auto-refresh\n    DATA_MANAGER.initAutoRefresh();\n\n\n\t// reset colum state of table\n\tdocument.getElementById('resetColumnStateButton').addEventListener(\n\t\t'click',\n\t\tasync () => {\n\t\t\tGRID_API.resetColumnState();\n\t\t\tcreateNotification('Column state reset', 'info');\n\t\t}\n\t);\n\n\t// Toggle visibility of runs\n\tdocument.getElementById('toggleVisibleRowsButton').addEventListener(\n\t\t'click',\n\t\t() => toggleRowsVisibility(true)\n\t);\n\n\tdocument.getElementById('toggleFilteredRowsButton').addEventListener(\n\t\t'click',\n\t\t() => toggleRowsVisibility(false)\n\t);\n}\n\n/*\n##    ##  #######  ######## #### ########\n###   ## ##     ##    ##     ##  ##\n####  ## ##     ##    ##     ##  ##\n## ## ## ##     ##    ##     ##  ######\n##  #### ##     ##    ##     ##  ##\n##   ### ##     ##    ##     ##  ##\n##    ##  #######     ##    #### ##\n*/\n\n\nfunction blinkElement(elementId, color, duration) {\n    const element = document.getElementById(elementId);\n    element.classList.add('blink-border');\n    setTimeout(() => {\n        element.classList.remove('blink-border');\n    }, 1000); // Remove class after animation completes\n}\n\nfunction createNotification(message, type = 'info', extra = null, show = true) {\n\tconst log_str = `[${type}]: ${message}\\n${extra ? extra : ''}`;\n\t// print to console\n\tswitch (type) {\n\t\tcase 'info':\n\t\t\tconsole.log(log_str);\n\t\t\tif (extra) { console.log(extra); };\n\t\t\tbreak;\n\t\tcase 'warning':\n\t\t\tconsole.warn(log_str);\n\t\t\tif (extra) { console.warn(extra); };\n\t\t\tbreak;\n\t\tcase 'error':\n\t\t\tconsole.error(log_str);\n\t\t\tif (extra) { console.error(extra); };\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tconsole.log(log_str);\n\t\t\tif (extra) { console.log(extra); };\n\t}\n\n\tif (show) {\n\t\t\n\t\t// create notification div\n\t\tconst notificationDiv = document.createElement('div');\n\t\tnotificationDiv.textContent = message;\n\t\tnotificationDiv.style.cssText = `\n\t\t\tposition: fixed;\n\t\t\ttop: 10px;\n\t\t\tright: 10px;\n\t\t\tpadding: 10px;\n\t\t\tborder-radius: 5px;\n\t\t\tbackground-color: ${NOTIFICATION_CONFIG.colors[type]};\n\t\t\tborder: 1px solid ${NOTIFICATION_CONFIG.border_colors[type]};\n\t\t\tbox-shadow: 0 2px 5px rgba(0,0,0,0.2);\n\t\t\ttransition: transform 0.3s ease-out, opacity 0.3s ease-out;\n\t\t\tz-index: 1000;\n\t\t\topacity: 0;  // Start with 0 opacity for fade-in effect\n\t\t`;\n\n\t\t// Function to update positions of all notifications\n\t\tfunction updateNotificationPositions() {\n\t\t\tconst notifications = document.querySelectorAll('.notification');\n\t\t\tlet currentTop = 10;\n\t\t\tnotifications.forEach((notification) => {\n\t\t\t\tnotification.style.transform = `translateY(${currentTop}px)`;\n\t\t\t\tcurrentTop += notification.offsetHeight + 10; // 10px gap between notifications\n\t\t\t});\n\t\t}\n\n\t\t// Add a class for easier selection\n\t\tnotificationDiv.classList.add('notification');\n\n\t\t// Insert the new notification at the top\n\t\tconst firstNotification = document.querySelector('.notification');\n\t\tif (firstNotification) {\n\t\t\tdocument.body.insertBefore(notificationDiv, firstNotification);\n\t\t} else {\n\t\t\tdocument.body.appendChild(notificationDiv);\n\t\t}\n\n\t\t// Trigger reflow to ensure the initial state is applied before changing opacity\n\t\tnotificationDiv.offsetHeight;\n\n\t\t// Fade in the notification\n\t\tnotificationDiv.style.opacity = '1';\n\n\t\t// Update positions after a short delay to allow for DOM update\n\t\tsetTimeout(updateNotificationPositions, 10);\n\n\t\t// Remove the notification after 3 seconds\n\t\tsetTimeout(\n\t\t\t() => {\n\t\t\t\tnotificationDiv.style.opacity = '0';\n\t\t\t\tnotificationDiv.style.transform += ' translateX(100%)';\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tnotificationDiv.remove();\n\t\t\t\t\tupdateNotificationPositions();\n\t\t\t\t}, 300); // Match this with the CSS transition time\n\t\t\t},\n\t\t\tNOTIFICATION_CONFIG.timeout,\n\t\t);\n\t}\n}\n\n\n/*\n########    ###    ########  ##       ########\n   ##      ## ##   ##     ## ##       ##\n   ##     ##   ##  ##     ## ##       ##\n   ##    ##     ## ########  ##       ######\n   ##    ######### ##     ## ##       ##\n   ##    ##     ## ##     ## ##       ##\n   ##    ##     ## ########  ######## ########\n*/\n\n\nfunction isISODate(value) {\n\t// This regex matches ISO 8601 date strings with optional fractional seconds and timezone information\n\tconst dateRegex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(.\\d+)?(Z|[+-]\\d{2}:\\d{2})?$/;\n\treturn dateRegex.test(value);\n}\n\n// fancy cell rendering -- hover/copy/open the data, make it emojis if its too long\nfunction fancyCellRenderer(params) {\n\t// check if params.value is undefined\n\tvar value;\n\tif (params.value === undefined) {\n\t\treturn div;\n\t}\n\telse {\n\t\tvalue = params.value;\n\t}\n\t// Create the div element\n\tvar div = document.createElement('div');\n\t// set content\n\tdiv.title = value;\n\tdiv.textContent = value;\n\tdiv.style.cursor = 'pointer';\n\t// if its too long, make it emojis\n\tif (value !== null) {\n\t\t// if object, convert to string\n\t\tif (typeof value === 'object') {\n\t\t\tvalue = JSON.stringify(value, null, 4);\n\t\t}\n\t\tif (value.length > 50) {\n\t\t\tdiv.title = value;\n\t\t\tdiv.innerHTML = feather.icons[\"mouse-pointer\"].toSvg() + feather.icons[\"copy\"].toSvg();\n\t\t\tdiv.style.cssText = 'font-size: 20px; display: flex; justify-content: center; align-items: center; background-color: #f4f4f4; border: 1px solid #d4d4d4; border-radius: 5px; height: 30px; width: 60px;';\n\t\t}\n\t}\n\n\t// Add click event listener to copy text to the clipboard\n\tdiv.onclick = function () {\n\t\tnavigator.clipboard.writeText(value).then(function () {\n\t\t\tconsole.log('Successfully copied to clipboard');\n\t\t}).catch(function (err) {\n\t\t\tconsole.error('Could not copy text to clipboard: ', err);\n\t\t});\n\t};\n\n\t// on right click, open a new plain text tab whose contents are the cell's value\n\tdiv.oncontextmenu = function () {\n\t\tconst newWindow = window.open('', '_blank');\n\t\t// set the contents of the new window to the cell's value\n\t\tnewWindow.document.write('<pre>' + value + '</pre>');\n\t\t// set the title of the page to the rows \"name.default_alias\" and the column's header\n\t\tnewWindow.document.title = params.node.data.id.run + ' : ' + params.colDef.headerName; // TODO: page has \"undefined\" in title\n\t\tnewWindow.document.close();\n\t};\n\n\t// Return the div as the cell's DOM\n\treturn div;\n}\n\n\nfunction createColumnDefs(summaryManifest) {\n\tvar columnDefs = [\n\t\t{\n\t\t\theaderName: 'View/Hide',\n\t\t\tfield: 'visible',\n\t\t\twidth: 100,\n\t\t\tcellRenderer: params => {\n\t\t\t\tconst cellDiv = document.createElement('div');\n\t\t\t\tcellDiv.className = 'ag-cell-wrapper';\n\t\t\t\tcellDiv.style.display = 'flex';\n\t\t\t\tcellDiv.style.alignItems = 'center';\n\t\t\t\tcellDiv.style.justifyContent = 'center';\n\n\t\t\t\tconst checkbox = document.createElement('input');\n\t\t\t\tcheckbox.type = 'checkbox';\n\t\t\t\tcheckbox.checked = params.value !== false;\n\t\t\t\tcheckbox.style.marginRight = '5px';\n\n\t\t\t\tconst iconDiv = document.createElement('div');\n\t\t\t\ticonDiv.innerHTML = feather.icons[checkbox.checked ? 'eye' : 'eye-off'].toSvg();\n\t\t\t\ticonDiv.style.pointerEvents = 'none'; // Make icon non-interactive\n\n\t\t\t\tcellDiv.appendChild(checkbox);\n\t\t\t\tcellDiv.appendChild(iconDiv);\n\n\t\t\t\tconst updateVisibility = (isVisible) => {\n\t\t\t\t\tparams.setValue(isVisible);\n\t\t\t\t\tcheckbox.checked = isVisible;\n\t\t\t\t\ticonDiv.innerHTML = feather.icons[isVisible ? 'eye' : 'eye-off'].toSvg();\n\t\t\t\t\tPLOT_MANAGER.updateTraceVisibility(params.data.id.syllabic, isVisible);\n\t\t\t\t};\n\n\t\t\t\tcheckbox.addEventListener('change', () => updateVisibility(checkbox.checked));\n\t\t\t\tcellDiv.addEventListener('click', (event) => {\n\t\t\t\t\tif (event.target !== checkbox) {\n\t\t\t\t\t\tupdateVisibility(!checkbox.checked);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn cellDiv;\n\t\t\t},\n\t\t},\n\t];\n\n\t// date filter\n\tconst date_def = {\n\t\tfilter: 'agDateColumnFilter',\n\t\tfilterParams: {\n\t\t\tcomparator: function (filterValue, cellValue) {\n\t\t\t\t// Assuming cellValue is an ISO date string\n\t\t\t\tconst cellDate = new Date(cellValue);\n\t\t\t\tconst filterDate = new Date(filterValue);\n\t\t\t\tif (cellDate < filterDate) {\n\t\t\t\t\treturn -1;\n\t\t\t\t} else if (cellDate > filterDate) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t},\n\t\t\t// Disable the use of the browser-provided date picker for this filter\n\t\t\tbrowserDatePicker: false,\n\t\t\t// Add the inRange filter option\n\t\t\tinRangeInclusive: true,\n\t\t}\n\t}\n\n\n\t// Define column groups\n\tconst columnGroupDefs = [\n\t\t{\n\t\t\theaderName: 'Name',\n\t\t\tchildren: [\n\t\t\t\t{ field: 'id.syllabic', headerName: 'Syllabic ID', columnGroupShow: null },\n\t\t\t\t{ field: 'id.run', headerName: 'Full Run ID', columnGroupShow: 'open' },\n\t\t\t],\n\t\t\tmarryChildren: true,\n\t\t},\n\t\t{\n\t\t\theaderName: 'Timing',\n\t\t\tchildren: [\n\t\t\t\t{ field: 'timing.start', headerName: 'Start', columnGroupShow: null, ...date_def },\n\t\t\t\t{ field: 'timing.final', headerName: 'End', columnGroupShow: 'open', ...date_def },\n\t\t\t\t{ field: 'timing.duration', headerName: 'Duration (ms)', columnGroupShow: 'open', },\n\t\t\t],\n\t\t\tmarryChildren: true,\n\t\t},\n\t\t{\n\t\t\theaderName: 'Final Metrics',\n\t\t\tchildren: [],\n\t\t},\n\t\t{\n\t\t\theaderName: 'Config',\n\t\t\tchildren: [\n\t\t\t\t{\n\t\t\t\t\tfield: 'config',\n\t\t\t\t\theaderName: 'Config',\n\t\t\t\t\t// width: 50, // TODO: this width is broken\n\t\t\t\t\tcellRenderer: fancyCellRenderer,\n\t\t\t\t\tvalueFormatter: params => {\n\t\t\t\t\t\tif (params.value === null || params.value === undefined) {\n\t\t\t\t\t\t\treturn '';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (typeof params.value === 'object') {\n\t\t\t\t\t\t\treturn JSON.stringify(params.value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn params.value.toString();\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t\tmarryChildren: true,\n\t\t},\n\t];\n\n\t// Dynamically add final metric columns\n\tconst finalMetricKeys = new Set();\n\tsummaryManifest.forEach(item => {\n\t\tObject.keys(item.final_metrics).forEach(key => finalMetricKeys.add(key));\n\t});\n\tvar final_metrics_counter = 0;\n\tfinalMetricKeys.forEach(key => {\n\t\tcolumnGroupDefs[2].children.push({\n\t\t\tfield: `final_metrics.${key}`,\n\t\t\theaderName: key,\n\t\t\tcolumnGroupShow: final_metrics_counter === 1 ? null : 'open',\n\t\t});\n\t\tfinal_metrics_counter += 1;\n\t});\n\n\t// Add column group definitions to the main column definitions\n\tcolumnDefs = columnDefs.concat(columnGroupDefs);\n\n\treturn columnDefs;\n}\n\nfunction adjustTableHeight(table) {\n\t// Adjust the height of the table container\n\tconst gridHeight = table.querySelector('.ag-center-cols-viewport').offsetHeight;\n\tconst headerHeight = table.querySelector('.ag-header').offsetHeight;\n\tconst paginationHeight = table.querySelector('.ag-paging-panel').offsetHeight;\n\tconst tableMinHeight = gridHeight + headerHeight + paginationHeight + 50;\n\ttable.style.minHeight = `${tableMinHeight}px`;\n}\n\nfunction toggleRowsVisibility(affectVisible) {\n\tconst visibleRows = new Set(GRID_API.getRenderedNodes().map(node => node.data.id.syllabic));\n\tlet rowsToToggle = [];\n\tlet newVisibility;\n\n\tGRID_API.forEachNode(node => {\n\t\tconst isVisible = visibleRows.has(node.data.id.syllabic);\n\t\tif (affectVisible === isVisible) {\n\t\t\trowsToToggle.push(node);\n\t\t}\n\t});\n\n\tif (rowsToToggle.length > 0) {\n\t\tnewVisibility = !rowsToToggle[0].data.visible;\n\t}\n\n\trowsToToggle.forEach(node => {\n\t\tnode.setDataValue('visible', newVisibility);\n\t\tLAYOUT_MANAGER.visibilityState[node.data.id.syllabic] = newVisibility;\n\t});\n\n\t// Update plots\n\tDATA_MANAGER.metricNames.forEach(metricName => {\n\t\tPLOT_MANAGER.updatePlot(metricName);\n\t});\n\n\tGRID_API.refreshCells({\n\t\tforce: true,\n\t\tcolumns: ['visible'],\n\t\trowNodes: rowsToToggle\n\t});\n}\n\nfunction createRunsManifestTable(summaryManifest) {\n\t// create plot container\n\tconst runsManifestTable = document.createElement('div');\n\trunsManifestTable.id = 'runsManifest';\n\trunsManifestTable.classList.add('runsManifestBox', 'ag-theme-alpine');\n\tdocument.getElementById('rootContainerDiv').appendChild(runsManifestTable);\n\n\t// load layout\n\tconst layout = LAYOUT_MANAGER.layout[runsManifestTable.id];\n\tif (layout) {\n\t\trunsManifestTable.style.cssText = `position: absolute; width: ${layout.width}px; height: ${layout.height}px; left: ${layout.x}px; top: ${layout.y}px; margin-bottom: 20px; ${DEFAULT_STYLE}`;\n\t}\n\t// make draggable\n\tLAYOUT_MANAGER.makeElementDraggable(runsManifestTable);\n\n\t// create the grid options\n\tconst gridOptions = {\n\t\tcolumnDefs: createColumnDefs(summaryManifest),\n\t\trowData: summaryManifest,\n\t\tpagination: true,\n\t\tenableCellTextSelection: true,\n\t\tenableBrowserTooltips: true,\n\t\trowSelection: 'multiple',\n\t\t// customize pagination\n\t\tpagination: true,\n\t\tpaginationPageSize: 10,\n\t\tpaginationPageSizeSelector: [1, 2, 5, 10, 25, 50, 100, 500, 1000],\n\t\tdefaultColDef: {\n\t\t\tresizable: true,\n\t\t\tfilter: true,\n\t\t\t// always show the floating filter\n\t\t\tfloatingFilter: true,\n\t\t\t// disable filter hamburger menu (for space)\n\t\t\tmenuTabs: [],\n\t\t},\n\t\tdomLayout: 'autoHeight',\n\t\tonFirstDataRendered: function (params) {\n\t\t\tadjustTableHeight(runsManifestTable);\n\t\t},\n\t\tonPaginationChanged: function (params) {\n\t\t\tadjustTableHeight(runsManifestTable);\n\t\t},\n\t\tinitialState: LAYOUT_MANAGER.grid_state,\n\t};\n\n\t// create the ag-Grid table, api to global\n\t// api is used in LayoutManager.updateGridState\n\tGRID_API = agGrid.createGrid(runsManifestTable, gridOptions);\n\n\t// load in the visibility state of the runs\n\tGRID_API.forEachNode(node => {\n\t\tconst runId = node.data.id.syllabic;\n\t\tconst isVisible = LAYOUT_MANAGER.visibilityState[runId] !== false;\n\t\tnode.setDataValue('visible', isVisible);\n\t});\n\tGRID_API.refreshCells({ force: true, columns: ['visible'] });\n\t// set the checkbox state\n\tGRID_API.onFilterChanged();\n}\n\n\n\n\n/*\n#### ##    ## #### ########\n ##  ###   ##  ##     ##\n ##  ####  ##  ##     ##\n ##  ## ## ##  ##     ##\n ##  ##  ####  ##     ##\n ##  ##   ###  ##     ##\n#### ##    ## ####    ##\n*/\n\n\nasync function init() {\n\t// load basic data\n\tawait DATA_MANAGER.loadManifest();\n\n\t// layout stuff\n\tLAYOUT_MANAGER = new LayoutManager(DATA_MANAGER.projectName);\n\tawait LAYOUT_MANAGER.loadLayout(do_update = false);\n\n\t// set up header and buttons\n\tawait headerButtons();\n\n\t// create empty plots\n\tawait PLOT_MANAGER.createAllPlots();\n\n\t// load data\n\tawait DATA_MANAGER.loadRuns();\n\n\t// populate table and get grid API\n\tawait createRunsManifestTable(DATA_MANAGER.summaryManifest);\n\n\t// populate plots\n\tawait PLOT_MANAGER.populateAllPlots();\n\n\t// feather icons\n\ttry {\n\t\t// replace the icons\n\t\tfeather.replace();\n\t\t// if no errors, look for any <i> tags with class `data-feather` and remove the text\n\t\tconst featherIcons = document.querySelectorAll('i[data-feather]');\n\t\tfeatherIcons.forEach(icon => {\n\t\t\ticon.innerHTML = '';\n\t\t});\n\t}\n\tcatch (e) {\n\t\tcreateNotification('Feather icons not found, keeping text fallback', 'error');\n\t}\n\tconsole.log('init complete');\n\n\tfeather.replace();\n\n\tawait DATA_MANAGER.refreshData()\n}\n</script></head>\n<body>\n<header id=\"mainHeader\">\n<h1 id=\"projectH1\">trnbl Dashboard</h1>\n<button class=\"headerButton\" id=\"refreshButton\">\n<i data-feather=\"refresh-cw\"></i><i data-feather=\"bar-chart-2\"></i>\n            Refresh Data\n        </button>\n<div class=\"headerButton\" id=\"autoRefreshButton\">\n<label for=\"autoRefreshSelect\">\n<i data-feather=\"refresh-cw\"></i><i data-feather=\"clock\"></i> Auto Refresh (s):\n            </label>\n<select id=\"autoRefreshSelect\"></select>\n</div>\n<button class=\"headerButton\" id=\"toggleVisibleRowsButton\">\n<i data-feather=\"eye\"></i><i data-feather=\"toggle-right\"></i>\n            Toggle Visible Rows\n        </button>\n<button class=\"headerButton\" id=\"toggleFilteredRowsButton\">\n<i data-feather=\"eye-off\"></i><i data-feather=\"toggle-left\"></i>\n            Toggle Filtered Rows\n        </button>\n<br/><br/>\n<button class=\"headerButton\" id=\"saveLayoutButton\">\n<i data-feather=\"save\"></i><i data-feather=\"layout\"></i>\n            Save Current Layout\n        </button>\n<button class=\"headerButton\" id=\"resetLayoutButton\">\n<i data-feather=\"refresh-ccw\"></i><i data-feather=\"layout\"></i>\n            Reset Layout</button>\n<button class=\"headerButton\" id=\"downloadLayoutButton\">\n<i data-feather=\"download\"></i><i data-feather=\"layout\"></i>\n            Download Current Layout\n        </button>\n<div class=\"headerButton\">\n<input id=\"gridSnapCheckbox\" type=\"checkbox\"/>\n<label for=\"gridSnapCheckbox\">\n<i data-feather=\"grid\"></i> Grid Snap\n            </label>\n</div>\n<button class=\"headerButton\" id=\"resetColumnStateButton\">\n<i data-feather=\"refresh-ccw\"></i><i data-feather=\"columns\"></i>\n            Reset Column Sizes\n        </button>\n<hr/>\n</header>\n<div class=\"rootContainer\" id=\"rootContainerDiv\">\n<div id=\"invisHbar\" style=\"width: 100em; height: 100em;\"></div>\n</div>\n<script>\n        document.addEventListener('DOMContentLoaded', init);\n    </script>\n</body>\n</html>"


if __name__ == "__main__":
	print(get_html_frontend())
