import json


def get_html_frontend() -> str:
	return "<!DOCTYPE html>\n\n<html>\n<head>\n<title>trnbl dashboard</title>\n<!-- packages from the web -->\n<script src=\"https://cdn.plot.ly/plotly-latest.min.js\"></script>\n<script src=\"https://unpkg.com/interactjs/dist/interact.min.js\"></script>\n<!-- ag-grid -->\n<script src=\"https://cdn.jsdelivr.net/npm/ag-grid-community/dist/ag-grid-community.min.js\"></script>\n<!-- feather icons -->\n<script src=\"https://unpkg.com/feather-icons\"></script>\n<!-- dashboard js file -->\n\n<!-- custom css -->\n\n<style>/* global font, and for plotly */\n* {\n\tfont-family: 'Roboto-mono', monospace;\n}\n/* same for any svg element */\nsvg {\n\tfont-family: 'Roboto-mono', monospace;\n}\n\n/* when hovering a draggable element */\n.draggable:hover {\n    z-index: 999;\n\tborder: 1px solid blue;\n\ttransition-delay: 0.5s;\n}\n.draggable {\n    transition: z-index 0.5s;\n}\n.draggable:not(:hover) {\n    transition-delay: 0.5s;\n}\n\n\n/* Make sure the font-family matches the one provided by ag-Grid */\n.ag-icon {\n    font-family: \"agGridAlpine\" !important; \n}\n\noption {\n    font-size: 2em !important; /* why isnt this working? */\n}\n\n.rootContainer {\n\t/* display: flex; */\n\t/* width: 100%; */\n\theight: 100%;\n\t/* flex-direction: column; */\n\t/* flex-direction: row; */\n}\n\n.plotContainer {\n\tborder: 1px solid black;\n\tbackground-color: #f0f0f0;\n\tborder-radius: 10px;\n\tpadding: 3px;\n}\n\n.runsManifestBox {\n\tborder: 1px solid black;\n\tbackground-color: #f0f0f0;\n\tborder-radius: 10px;\n\tpadding: 3px;\n}\n\n.plotSettings {\n\t/* left margin */\n\tmargin-left: 2px;\n}\n\n.headerButton {\n\theight: 35px; /* Set the desired height for the buttons */\n\tfont-size: 16px;\n\tline-height: 30px;\n\tpadding: 0 10px;\n\tcursor: pointer;\n    display: inline-block;\n\tcolor: #000000;\n\tbackground-color: #d8d8d8;\n\tborder: 1px solid #3c3c3c;\n\tborder-radius: 5px;\n\ttext-align: center;\n\tfont-size: 16px;\n\ttransition: background-color 0.1s, border-color 0.1s, color 0.1s;\n}\n.headerButton:hover, .headerButton:focus {\n\tbackground-color: #797979;\n\tborder-color: #213244;\n\tcolor: #000000;\n}\n.headerButton svg {\n\t/* vertically centered svg */\n\tvertical-align: middle;\n}\n\nhr {\n\tmargin-top: 10px; /* Adjust the margin as needed */\n\tborder: none;\n\tborder-top: 1px solid #ccc; /* Set the desired color and style for the horizontal rule */\n}\n\n\n.axis-toggle-container {\n\tmargin-top: 10px;\n}\n\n/* .plot-div {\n\tmargin-bottom: 20px;\t\n}\n\n.plotContainer {\n\ttouch-action: none;\n\tbox-sizing: border-box;\n} */\n\n/* The switch - the box around the slider */\n.switch {\n\tposition: relative;\n\tdisplay: inline-block;\n\twidth: 3em;\n\theight: 1.5em;\n}\n\n/* Hide default HTML checkbox */\n.switch input {\n\topacity: 0;\n\twidth: 0;\n\theight: 0;\n}\n\n/* The slider */\n.slider {\n\tposition: absolute;\n\tcursor: pointer;\n\ttop: 0;\n\tleft: 0;\n\tright: 0;\n\tbottom: 0;\n\tbackground-color: #ccc;\n\t-webkit-transition: .4s;\n\ttransition: .4s;\n}\n\n.slider:before {\n\tposition: absolute;\n\tcontent: \"\";\n\theight: 1em;\n\twidth: 1em;\n\tleft: 4px;\n\tbottom: 4px;\n\tbackground-color: white;\n\t-webkit-transition: .4s;\n\ttransition: .4s;\n}\n\ninput:checked + .slider {\n\tbackground-color: #2196F3;\n}\n\ninput:focus + .slider {\n\tbox-shadow: 0 0 1px #2196F3;\n}\n\ninput:checked + .slider:before {\n\t-webkit-transform: translateX(1.5em);\n\t-ms-transform: translateX(1.5em);\n\ttransform: translateX(1.5em);\n}\n\n/* Rounded sliders */\n.slider.round {\n\tborder-radius: 34px;\n}\n\n.slider.round:before {\n\tborder-radius: 50%;\n}</style><script>/*\n ######   #######  ##    ##  ######  ########  ######\n##    ## ##     ## ###   ## ##    ##    ##    ##    ##\n##       ##     ## ####  ## ##          ##    ##\n##       ##     ## ## ## ##  ######     ##     ######\n##       ##     ## ##  ####       ##    ##          ##\n##    ## ##     ## ##   ### ##    ##    ##    ##    ##\n ######   #######  ##    ##  ######     ##     ######\n*/\n\n\nlet LAYOUT_MANAGER = null;\nlet PLOTLY_LAYOUTS = {};\nlet GRID_API = null;\n// const xUnitsKeys = ['samples', 'batches', \"timestamp\"]; // TODO: read dynamically, add epochs & runs\nconst DEFAULT_XUNITS = 'samples';\n\n// settings\nconst SETTINGS_WIDTH_PX = 100;\nconst PLOT_BOTTOM_MARGIN_PX = 5;\nconst SNAP_INTERVAL_DEFAULT = 50;\nconst NOTIFICATION_COLORS = {\n    'info': 'lightgreen',\n    'warning': 'lightyellow',\n    'error': 'lightcoral',\n};\n\nconst NOTIFICATION_BORDER_COLORS = {\n    'info': 'green',\n    'warning': 'orange',\n    'error': 'red',\n};\nconst DEFAULT_STYLE = {\n\tborder: '1px solid black',\n\tbackgroundColor: '#f0f0f0',\n\tborderRadius: '10px',\n\tpadding: '3px',\n}\nconst PLOTLY_LAYOUT_MARGIN = { l: 40, r: 30, b: 40, t: 50, pad: 0 };\n\n\n/*\n####  #######     ##     ## ##    ##  ######\n ##  ##     ##    ###   ### ###   ## ##    ##\n ##  ##     ##    #### #### ####  ## ##\n ##  ##     ##    ## ### ## ## ## ## ##   ####\n ##  ##     ##    ##     ## ##  #### ##    ##\n ##  ##     ##    ##     ## ##   ### ##    ##\n####  #######     ##     ## ##    ##  ######\n*/\n\nclass IOManager {\n\tconstructor() {\n        this.fileTimestamps = {};\n    }\n\n    async fetchJson(path) {\n        try {\n            const response = await fetch(path);\n            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n            return await response.json();\n        } catch (error) {\n            console.error('Fetch JSON error:', error);\n            return null;\n        }\n    }\n\n    async fetchJsonLines(path) {\n\t\ttry {\n\t\t  const response = await fetch(path);\n\t\t  if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n\t\t  const text = await response.text();\n\t\t  const lines = text.trim().split('\\n');\n\t\t  const validLines = lines.slice(0, -1).map(line => JSON.parse(line));\n\t  \n\t\t  // Try parsing the last line\n\t\t  try {\n\t\t\tconst lastLine = JSON.parse(lines[lines.length - 1]);\n\t\t\tvalidLines.push(lastLine);\n\t\t  } catch (error) {\n\t\t\tconsole.error(`Invalid JSON in the last line of ${path}: `, error);\n\t\t  }\n\t  \n\t\t  return validLines;\n\t\t} catch (error) {\n\t\t  console.error('Fetch JSON Lines error:', error);\n\t\t  return null;\n\t\t}\n\t  }\n\n\tasync saveJsonLocal(name, data) {\n\t\tconst data_json = JSON.stringify(data);\n\t\tlocalStorage.setItem(name, btoa(data_json));\n\t}\n\t\n\tasync readJsonLocal(name) {\n\t\tconst data_encoded = localStorage.getItem(name);\n\t\tif (data_encoded) {\n\t\t\tconst data_json = atob(data_encoded);\n\t\t\treturn JSON.parse(data_json);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tasync deleteJsonLocal(name) {\n\t\tlocalStorage.removeItem(name);\n\t}\n\n\tasync getFileModificationTime(path) {\n        try {\n            const response = await fetch(path, { method: 'HEAD' });\n            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n            return new Date(response.headers.get('Last-Modified'));\n        } catch (error) {\n            console.error('Error fetching file modification time:', error);\n            return null;\n        }\n    }\n\n    async fetchJsonIfModified(path) {\n        const lastModified = await this.getFileModificationTime(path);\n        if (!lastModified) return null;\n\n        if (!this.fileTimestamps[path] || lastModified > this.fileTimestamps[path]) {\n            const data = await this.fetchJson(path);\n            if (data !== null) {\n                this.fileTimestamps[path] = lastModified;\n            }\n            return data;\n        }\n        return null; // File not modified\n    }\n\n    async fetchJsonLinesIfModified(path) {\n        const lastModified = await this.getFileModificationTime(path);\n        if (!lastModified) return null;\n\n        if (!this.fileTimestamps[path] || lastModified > this.fileTimestamps[path]) {\n            const data = await this.fetchJsonLines(path);\n            if (data !== null) {\n                this.fileTimestamps[path] = lastModified;\n            }\n            return data;\n        }\n        return null; // File not modified\n    }\n}\n\nconst IO_MANAGER = new IOManager();\n\n\n/*\n########  ##     ## ##    ##    ########     ###    ########    ###\n##     ## ##     ## ###   ##    ##     ##   ## ##      ##      ## ##\n##     ## ##     ## ####  ##    ##     ##  ##   ##     ##     ##   ##\n########  ##     ## ## ## ##    ##     ## ##     ##    ##    ##     ##\n##   ##   ##     ## ##  ####    ##     ## #########    ##    #########\n##    ##  ##     ## ##   ###    ##     ## ##     ##    ##    ##     ##\n##     ##  #######  ##    ##    ########  ##     ##    ##    ##     ##\n*/\n\nclass RunData {\n    constructor(path) {\n        this.path = path;\n        this.config = null;\n        this.meta = null;\n        this.metrics = null;\n        this.logs = null;\n        this.artifacts = null;\n    }\n\n    async loadData() {\n        this.config = await IO_MANAGER.fetchJson(`${this.path}/config.json`);\n        this.meta = await IO_MANAGER.fetchJson(`${this.path}/meta.json`);\n        this.metrics = await IO_MANAGER.fetchJsonLines(`${this.path}/metrics.jsonl`);\n        this.logs = await IO_MANAGER.fetchJsonLines(`${this.path}/log.jsonl`);\n        this.artifacts = await IO_MANAGER.fetchJsonLines(`${this.path}/artifacts.jsonl`);\n    }\n\n    pairMetrics(xKey, yKey) {\n        const xVals = [];\n        const yVals = [];\n        if (this.metrics) {\n            this.metrics.forEach(metric => {\n                const xv = metric[xKey];\n\t\t\t\tconst yv = metric[yKey];\n\t\t\t\tif ( !isNaN(xv) && !isNaN(yv)) {\n                    xVals.push(xv);\n                    yVals.push(yv);\n                }\n            });\n        }\n        return [xVals, yVals];\n    }\n\n\tstatic smoothData(data, span = null, method = 'SMA') {\n\t\tif (data.some(isNaN)) {\n\t\t\tcreateNotification('Data contains NaN values', 'warning');\n\t\t}\n\n\t\tif (!span) {\n\t\t\treturn data;\n\t\t}\n\t\t\n\t\tconst smoothed = [];\n\t\tswitch(method) {\n\t\t\tcase 'SMA':\n\t\t\t\tfor (let i = 0; i < data.length; i++) {\n\t\t\t\t\tconst start = Math.max(0, i - span + 1);\n\t\t\t\t\tconst window = data.slice(start, i + 1);\n\t\t\t\t\tconst sum = window.reduce((acc, val) => acc + val, 0);\n\t\t\t\t\tconst avg = sum / window.length;\n\t\t\t\t\tsmoothed.push(avg);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'EMA':\n\t\t\t\tlet ema = data[0]; // Starting with the first data point\n\t\t\t\tconst alpha = 2 / (span + 1);\n\t\t\t\tfor (let i = 0; i < data.length; i++) {\n\t\t\t\t\tema = alpha * data[i] + (1 - alpha) * (i > 0 ? ema : data[i]);\n\t\t\t\t\tsmoothed.push(ema);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'Gaussian':\n\t\t\t\t// Gaussian smoothing requires calculating weights for each point in the window\n\t\t\t\t// We'll use a simplified Gaussian kernel for demonstration purposes\n\t\t\t\tfor (let i = 0; i < data.length; i++) {\n\t\t\t\t\tlet weightedSum = 0;\n\t\t\t\t\tlet weightSum = 0;\n\t\t\t\t\tfor (let j = -span; j <= span; j++) {\n\t\t\t\t\t\tif (i + j >= 0 && i + j < data.length) {\n\t\t\t\t\t\t\t// Calculate the Gaussian weight\n\t\t\t\t\t\t\tconst weight = Math.exp(-(j * j) / (2 * span * span));\n\t\t\t\t\t\t\tweightedSum += data[i + j] * weight;\n\t\t\t\t\t\t\tweightSum += weight;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tconst gaussianAverage = weightedSum / weightSum;\n\t\t\t\t\tsmoothed.push(gaussianAverage);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tconsole.error(\"Invalid smoothing method.\");\n\t\t\t\treturn [];\n\t\t}\n\t\n\t\treturn smoothed;\n\t}\n}\n\n/*\n########     ###    ########    ###       ##     ## ##    ##  ######\n##     ##   ## ##      ##      ## ##      ###   ### ###   ## ##    ##\n##     ##  ##   ##     ##     ##   ##     #### #### ####  ## ##\n##     ## ##     ##    ##    ##     ##    ## ### ## ## ## ## ##   ####\n##     ## #########    ##    #########    ##     ## ##  #### ##    ##\n##     ## ##     ##    ##    ##     ##    ##     ## ##   ### ##    ##\n########  ##     ##    ##    ##     ##    ##     ## ##    ##  ######\n*/\n\nclass DataManager {\n    constructor() {\n        this.manifest = null;\n        this.allRuns = {};\n        this.metricNames = new Set();\n        this.projectName = null;\n        this.summaryManifest = null;\n        this.lastRefreshTime = null;\n\t\tthis.updatedRuns = new Set();\n    }\n\n\tasync loadManifest() {\n\t\t// load data\n\t\tthis.manifest = await IO_MANAGER.fetchJsonLines('runs.jsonl');\n\t\tif (!this.manifest) {\n\t\t\tcreateNotification('Failed to load manifest', 'error');\n\t\t}\n\t\t\n\t\t// get project name, metric names\n\t\tconst projectNames = new Set();\n\t\tfor (const run of this.manifest) {\n\t\t\tprojectNames.add(run.project);\n\n\t\t\trun.metric_names.forEach(metricName => {\n\t\t\t\tthis.metricNames.add(metricName);\n\t\t\t});\n\t\t}\n\t\t// project names should match\n        if (projectNames.size === 1) {\n            this.projectName = projectNames.values().next().value;\n        } else {\n            // console.error('Project names are not consistent across runs', projectNames);\n\t\t\tcreateNotification(`Project names are not consistent across runs: ${projectNames}`, 'error');\n        }\n\t}\n\n\tasync loadRuns() {\n\t\t// load manifest if not already loaded\n\t\tif (!this.manifest) {\n\t\t\tthis.loadManifest();\n\t\t}\n\t\t\n\t\t// load each run\n\t\tfor (const run of this.manifest) {\n\t\t\tconst runData = new RunData(`runs/${run.run_id}`);\n\t\t\tawait runData.loadData();\n\t\t\tthis.allRuns[run.run_id] = runData;\n\t\t}\n\t\t\n\t\t// update summary manifest (final metrics, timestamps, etc)\n\t\tthis.updateSummaryManifest();\n\t}\n\n    updateSummaryManifest() {\n\t\t// make sure there are runs\n\t\ttry {\n\t\t\tif (Object.keys(this.allRuns).length === 0) {\n\t\t\t\tthrow 'No runs found';\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tcreateNotification(`Could not find any runs to update summary manifest: ${error}`, 'error');\n\t\t}\n\n\t\t// create the summary manifest dictionary\n        this.summaryManifest = Object.values(this.allRuns).map(run => {\n            // final timestamp, from logs\n\t\t\tconst finalTimestamp = run.logs.length > 0 ? run.logs[run.logs.length - 1].timestamp : null;\n\n\t\t\t// final values for each metric\n            let finalMetrics = {};\n\t\t\t// Iterate over the metrics array in reverse to find the last value for each metricName\n\t\t\tfor (let i = run.metrics.length - 1; i >= 0; i--) {\n\t\t\t\tthis.metricNames.forEach(metricName => {\n\t\t\t\t\t// Check if the metric name is present in the current metric and hasn't been added to lastValues yet\n\t\t\t\t\tif (run.metrics[i][metricName] !== undefined && finalMetrics[metricName] === undefined) {\n\t\t\t\t\t\tfinalMetrics[metricName] = run.metrics[i][metricName];\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\t// return the summary manifest object, for each run\n            return {\n\t\t\t\tid: {\n\t\t\t\t\tsyllabic: run.meta.syllabic_id,\n\t\t\t\t\trun: run.meta.run_id,\n\t\t\t\t},\n\t\t\t\ttiming: {\n\t\t\t\t\tstart: run.meta.run_init_timestamp,\n\t\t\t\t\tfinal: finalTimestamp,\n\t\t\t\t\tduration: new Date(finalTimestamp) - new Date(run.meta.run_init_timestamp),\n\t\t\t\t},\n\t\t\t\tfinal_metrics: finalMetrics,\n\t\t\t\tconfig: run.config,\n            };\n        });\n    }\n\n\tasync refreshData() {\n        console.log(\"Checking for updated data...\");\n        let dataUpdated = false;\n        this.updatedRuns.clear(); // Clear the set at the start of each refresh\n        \n        // Refresh manifest\n        const newManifest = await IO_MANAGER.fetchJsonLinesIfModified('runs.jsonl');\n        if (newManifest) {\n            this.manifest = newManifest;\n            dataUpdated = true;\n            console.log(\"Manifest updated\");\n            createNotification(\"Manifest file updated\", \"info\");\n        }\n\n        // Refresh run data\n        for (const run of this.manifest) {\n            const runPath = `runs/${run.run_id}`;\n            const newConfig = await IO_MANAGER.fetchJsonIfModified(`${runPath}/config.json`);\n            const newMeta = await IO_MANAGER.fetchJsonIfModified(`${runPath}/meta.json`);\n            const newMetrics = await IO_MANAGER.fetchJsonLinesIfModified(`${runPath}/metrics.jsonl`);\n            const newLogs = await IO_MANAGER.fetchJsonLinesIfModified(`${runPath}/log.jsonl`);\n            const newArtifacts = await IO_MANAGER.fetchJsonLinesIfModified(`${runPath}/artifacts.jsonl`);\n\n            if (newConfig || newMeta || newMetrics || newLogs || newArtifacts) {\n                const runData = this.allRuns[run.run_id] || new RunData(runPath);\n                if (newConfig) runData.config = newConfig;\n                if (newMeta) runData.meta = newMeta;\n                if (newMetrics) runData.metrics = newMetrics;\n                if (newLogs) runData.logs = newLogs;\n                if (newArtifacts) runData.artifacts = newArtifacts;\n                this.allRuns[run.run_id] = runData;\n                dataUpdated = true;\n                this.updatedRuns.add(run.run_id);\n                console.log(`Updated data for run ${run.run_id}`);\n            }\n        }\n\n        if (dataUpdated) {\n            // Update metric names\n            this.metricNames.clear();\n            for (const run of this.manifest) {\n                run.metric_names.forEach(metricName => {\n                    this.metricNames.add(metricName);\n                });\n            }\n\n            // Update summary manifest\n            this.updateSummaryManifest();\n\n            this.lastRefreshTime = new Date();\n            console.log(\"Data refresh completed\");\n        } else {\n            console.log(\"No updates found\");\n        }\n\n        return dataUpdated;\n    }\n\n    getUpdatedRunsInfo() {\n        return {\n            count: this.updatedRuns.size,\n            runs: Array.from(this.updatedRuns)\n        };\n    }\n}\n\nconst DATA_MANAGER = new DataManager();\n\n\n\n\n/*\n##          ###    ##    ##  #######  ##     ## ########\n##         ## ##    ##  ##  ##     ## ##     ##    ##\n##        ##   ##    ####   ##     ## ##     ##    ##\n##       ##     ##    ##    ##     ## ##     ##    ##\n##       #########    ##    ##     ## ##     ##    ##\n##       ##     ##    ##    ##     ## ##     ##    ##\n######## ##     ##    ##     #######   #######     ##\n*/\n\nclass LayoutManager {\n    constructor(\n\t\t\tprojectName, \n\t\t\tdefault_plot_cont_height = 300, \n\t\t\tplotcont_frac = 0.4,\n\t\t) {\n\t\tthis.projectName = projectName;\n\t\tthis.layout = {};\n\t\tthis.do_snap = true;\n\t\tthis.snapInterval = SNAP_INTERVAL_DEFAULT;\n\t\tthis.plot_configs = {};\n\t\tthis.grid_state = null;\n\t\t// default layout stuff\n\t\tthis.init_y = this.round_to_snap_interval(130),\n\t\tthis.default_plot_cont_height = this.round_to_snap_interval(default_plot_cont_height);\n\t\t// calculate widths\n\t\tconst window_width = window.innerWidth;\n\t\tthis.default_plot_cont_width = this.round_to_snap_interval(window_width * plotcont_frac);\n\t\tthis.table_width = this.round_to_snap_interval(window_width - (this.default_plot_cont_width + this.snapInterval));\n    }\n\n\tround_to_snap_interval(value) {\n\t\treturn Math.ceil(value / this.snapInterval) * this.snapInterval;\n\t}\n\n\tget_default_layout(\n\t\tplot_names, \n\t\tupdate_to_default = true,\n\t) {\n\t\t// convert plot_names to list\n\t\tconst plot_names_arr = Array.from(plot_names);\n\t\n\t\t// init layout\n\t\tvar layout = {};\n\t\tconst plot_y_step = this.round_to_snap_interval(this.default_plot_cont_height * 1.1)\n\t\n\t\t// plot containers\n\t\tfor (let i = 0; i < plot_names_arr.length; i++) {\n\t\t\tconst metricName = plot_names_arr[i];\n\t\t\tlayout[`plotContainer-${metricName}`] = {\n\t\t\t\tx: 0,\n\t\t\t\ty: this.init_y + i * plot_y_step,\n\t\t\t\theight: this.default_plot_cont_height,\n\t\t\t\twidth: this.default_plot_cont_width,\n\t\t\t};\n\t\t};\n\t\n\t\t// table\n\t\tlayout['runsManifest'] = {\n\t\t\tx: this.default_plot_cont_width + SNAP_INTERVAL_DEFAULT,\n\t\t\ty: this.init_y,\n\t\t\theight: 800,\n\t\t\twidth: this.table_width,\n\t\t};\n\t\n\t\t// write to global\n\t\tif (update_to_default) {\n\t\t\tthis.layout = layout;\n\t\t}\n\n\t\treturn layout;\n\t}\n\n\tasync getDefaultPlotConfig() {\n        return {\n            size: { width: this.default_plot_cont_width - SETTINGS_WIDTH_PX, height: this.default_plot_cont_height },\n            axisScales: { x: 'linear', y: 'linear' },\n\t\t\tsmoothing_method: 'SMA',\n            smoothing_span: null,\n\t\t\txUnits: DEFAULT_XUNITS,\n        };\n    }\n\n\tasync getPlotConfig(metricName) {\n\t\tif (!(metricName in this.plot_configs)) {\n\t\t\tthis.plot_configs[metricName] = await this.getDefaultPlotConfig();\n\t\t}\n\t\treturn this.plot_configs[metricName];\n\t}\n\n    makeElementDraggable(element) {\n\t\t// get id and position\n        const id = element.id;\n        let position = this.getInitialPosition(element);\n\n\t\t// add .draggable class if its not there\n\t\tif (!element.classList.contains('draggable')) {\n\t\t\telement.classList.add('draggable');\n\t\t}\n\n\t\t// make draggable and resizable\n        this.initializeDragInteraction(element, position);\n        this.initializeResizeInteraction(element, position);\n\t\t\n\t\t// update layout\n        this.updateElementLayout(element, position.x, position.y, true);\n    }\n\n    getInitialPosition(element) {\n        const id = element.id;\n        if (this.layout[id]) {\n            return { x: this.layout[id].x, y: this.layout[id].y };\n        } else {\n            return {\n                x: parseFloat(element.getAttribute('data-x')) || 0,\n                y: parseFloat(element.getAttribute('data-y')) || 0,\n            };\n        }\n    }\n\n    initializeDragInteraction(element, position) {\n        interact(element).draggable({\n            ignoreFrom: '.draglayer, .ag-header, .ag-center-cols-container, .no-drag, .legend, .bg, .scrollbox',\n            modifiers: [\n                interact.modifiers.snap({\n                    targets: [interact.snappers.grid({ x: this.snapInterval, y: this.snapInterval })],\n                    range: Infinity,\n                    relativePoints: [{ x: 0, y: 0 }]\n                }),\n                interact.modifiers.restrict({\n                    restriction: 'parent',\n                    elementRect: { top: 0, left: 0, bottom: 1, right: 1 },\n                    endOnly: true\n                })\n            ],\n            inertia: true\n        }).on('dragmove', (event) => {\n            position.x += event.dx;\n            position.y += event.dy;\n\n            this.updateElementLayout(event.target, position.x, position.y, true);\n        });\n    }\n\n    initializeResizeInteraction(element, position) {\n        interact(element).resizable({\n            edges: { left: true, right: true, bottom: true, top: true },\n            modifiers: [\n                interact.modifiers.snapSize({\n                    targets: [interact.snappers.grid({ width: this.snapInterval, height: this.snapInterval })],\n                    range: Infinity,\n                }),\n                interact.modifiers.restrictSize({\n                    min: { width: 250, height: 150 }\n                }),\n            ],\n            inertia: true\n        }).on('resizemove', (event) => {\n            const { width, height } = event.rect;\n            position.x += event.deltaRect.left;\n            position.y += event.deltaRect.top;\n\n\t\t\tconst target = event.target;\n            this.updateElementLayout(target, position.x, position.y, false, width, height);\n\n\t\t\tconst isPlotContainer = target.classList.contains('plotContainer');\n\t\t\tif (isPlotContainer) {\n\t\t\t\t// Adjust sizes of plotDiv and plotSettings inside the container\n\t\t\t\tconst plotSettings = target.querySelector('.plotSettings');\n\t\t\t\tconst plotDiv = target.querySelector('.plotDiv');\n\n\t\t\t\t// Set plotSettings width and adjust plotDiv width\n\t\t\t\tvar plotDivWidth = event.rect.width - SETTINGS_WIDTH_PX;\n\t\t\t\tplotSettings.style.width = plotDivWidth;\n\n\t\t\t\t// Update plotDiv and Plotly plot size\n\t\t\t\tplotDiv.style.width = `${plotDivWidth}px`;\n\t\t\t\tplotDiv.style.height = `${event.rect.height}px`;\n\n\t\t\t\t// Now, instruct Plotly to resize the plot\n\t\t\t\tconst plotID = plotDiv.id;\n\t\t\t\tPlotly.relayout(plotID, {\n\t\t\t\t\twidth: plotDivWidth, // New width for the plot\n\t\t\t\t\theight: event.rect.height - PLOT_BOTTOM_MARGIN_PX, // New height for the plot\n\t\t\t\t});\n\n\t\t\t\t// save in plot configs\n\t\t\t\tconst metricName = plotID.split('-')[1];\n\t\t\t\tthis.plot_configs[metricName].size = { width: plotDivWidth, height: event.rect.height };\n\t\t\t\tPLOTLY_LAYOUTS[metricName].width = plotDivWidth;\n\t\t\t\tPLOTLY_LAYOUTS[metricName].height = event.rect.height - PLOT_BOTTOM_MARGIN_PX;\n\t\t\t}\n        });\n    }\n\n    updateElementLayout(element, x, y, updatePosition = true, width = null, height = null) {\n\t\t// update position if provided\n        if (updatePosition) {\n            // element.style.transform = `translate(${x}px, ${y}px)`;\n            // element.setAttribute('data-x', x);\n            // element.setAttribute('data-y', y);\n\t\t\telement.style.left = `${x}px`;\n\t\t\telement.style.top = `${y}px`;\n        }\n\n\t\t// update width and height if provided\n        if (width && height) {\n            element.style.width = `${width}px`;\n            element.style.height = `${height}px`;\n        }\n\t\telse {\n\t\t\twidth = element.offsetWidth;\n\t\t\theight = element.offsetHeight;\n\t\t}\n\n\t\t// store in layout\n\t\tthis.layout[element.id] = {\n\t\t\tx: x,\n\t\t\ty: y,\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t};\n\t\t// console.log('Updated layout for:', element.id, this.layout[element.id]);\n    }\n\n\tupdateAllLayouts() {\n\t\tfor (const id in this.layout) {\n\t\t\tconst new_layout = this.layout[id];\n\t\t\tconst element = document.getElementById(id);\n\t\t\t// console.log('Updating layout for: ', id, new_layout);\n\t\t\tconst position = this.getInitialPosition(element);\n\t\t\tthis.updateElementLayout(element, new_layout.x, new_layout.y, true, new_layout.width, new_layout.height);\n\t\t}\n\t}\n\n\tget_local_storage_key() {\n\t\treturn `${this.projectName}_layout`;\n\t}\n\n    async saveLayout() {\n\t\tthis.updateGridState();\n        const layoutKey = this.get_local_storage_key();\n        IO_MANAGER.saveJsonLocal(layoutKey, this);\n\t\tconst layout_read = await IO_MANAGER.readJsonLocal(layoutKey);\n\t\tif (layout_read && (JSON.stringify(layout_read) == JSON.stringify(this))) {\n\t\t\tconsole.log('Layout saved:', layout_read);\n\t\t\tcreateNotification('Layout saved', 'info');\n\t\t} else {\n\t\t\tconsole.error('Layout not saved:', this, layout_read);\n\t\t\tcreateNotification('Layout not saved', 'error');\n\t\t}\n    }\n\n\tasync loadLayout(do_update = true) {\n\t\tconst layoutKey = this.get_local_storage_key();\n\t\tconst savedLayout = await IO_MANAGER.readJsonLocal(layoutKey);\n\t\tif (savedLayout) {\n\t\t\tthis.projectName = savedLayout.projectName;\n\t\t\tthis.layout = savedLayout.layout;\n\t\t\tthis.do_snap = savedLayout.do_snap;\n\t\t\tthis.snapInterval = savedLayout.snapInterval;\n\t\t\tthis.plot_configs = savedLayout.plot_configs;\n\t\t\tthis.grid_state = savedLayout.grid_state;\n\t\t} else {\n\t\t\tthis.layout = this.get_default_layout(DATA_MANAGER.metricNames);\n\t\t}\n\t\tconsole.log('Layout loaded:', this);\n\t\tif (do_update) {\n\t\t\tthis.updateAllLayouts();\n\t\t}\n\t}\n\n\tasync updateSnap(do_snap = true, snapInterval = SNAP_INTERVAL_DEFAULT) {\n\t\tthis.do_snap = do_snap;\n\t\tif (!do_snap) {\n\t\t\tsnapInterval = 1;\n\t\t}\n\t\tthis.snapInterval = snapInterval;\n\n\t\tconsole.log('Snap settings updated:', this.do_snap, this.snapInterval);\n\n\t\tfor (const id in this.layout) {\n\t\t\tconst element = document.getElementById(id);\n\t\t\tlet position = this.getInitialPosition(element);\n\n\t\t\tthis.initializeDragInteraction(element, position);\n\t\t\tthis.initializeResizeInteraction(element, position);\n\t\t}\n\t}\n\n\tupdateGridState() {\n\t\tthis.grid_state = GRID_API.getState();\n\t}\n}\n\n\n\n/*\n########  ##        #######  ########     ######  ########  ######\n##     ## ##       ##     ##    ##       ##    ## ##       ##    ##\n##     ## ##       ##     ##    ##       ##       ##       ##\n########  ##       ##     ##    ##       ##       ######   ##   ####\n##        ##       ##     ##    ##       ##       ##       ##    ##\n##        ##       ##     ##    ##       ##    ## ##       ##    ##\n##        ########  #######     ##        ######  ##        ######\n*/\n\nclass PlotManager {\n    constructor() {\n        this.plots = {}; // Keyed by metricName, values are objects with Plotly plot div ID and settings\n    }\n\n    async createPlot(metricName) {\n\t\t// get ids\n\t\tconst plotContainer_id = `plotContainer-${metricName}`;\n\t\tconst plotDiv_id = `plot-${metricName}`;\n\t\tconst plotSettings_id = `plotSettings-${metricName}`;\n\t\t\n\t\t// config and layout\n\t\tconst plotConfig = await LAYOUT_MANAGER.getPlotConfig(metricName);\n\t\tconst layout = LAYOUT_MANAGER.layout[plotContainer_id];\n\t\n\t\tconst plotContainerHTML = `\n\t\t\t<div\n\t\t\t\tid=\"${plotContainer_id}\"\n\t\t\t\tclass=\"plotContainer\" \n\t\t\t\tstyle=\"margin-bottom: 10px; display: flex; flex-direction: row; position: absolute; width: ${layout.width}px; height: ${layout.height}px; left: ${layout.x}px; top: ${layout.y}px; ${DEFAULT_STYLE}\"\n\t\t\t>\n\t\t\t\t<div \n\t\t\t\t\tid=\"${plotDiv_id}\"\n\t\t\t\t\tclass=\"plotDiv\" \n\t\t\t\t\tstyle=\"width: ${layout.width - SETTINGS_WIDTH_PX}px; height: ${layout.height - PLOT_BOTTOM_MARGIN_PX}px;\"\n\t\t\t\t></div>\n\t\t\t\t<div \n\t\t\t\t\tid=\"${plotSettings_id}\"\n\t\t\t\t\tclass=\"plotSettings\" \n\t\t\t\t\tstyle=\"width: ${SETTINGS_WIDTH_PX}; flex-shrink: 0; flex-grow: 0;\"\n\t\t\t\t></div>\n\t\t\t</div>\n\t\t`;\n\t\n\t\t// Add plot container to the root div\n\t\tdocument.getElementById('rootContainerDiv').insertAdjacentHTML('beforeend', plotContainerHTML);\n\t\n\t\t// Store plot info for later reference\n\t\tthis.plots[metricName] = {\n\t\t\tplotID: plotDiv_id,\n\t\t\tcontainerID: plotContainer_id,\n\t\t\tsettingsID: plotSettings_id,\n\t\t};\n\t\n\t\t// Specify plot layout and create empty plot\n\t\tconst plotly_layout = {\n\t\t\ttitle: `${metricName} over ${plotConfig.xUnits}`,\n\t\t\tautosize: true,\n\t\t\txaxis: {\n\t\t\t\ttitle: plotConfig.xUnits,\n\t\t\t\ttype: plotConfig.axisScales.x,\n\t\t\t\tshowgrid: true,\n\t\t\t},\n\t\t\tyaxis: {\n\t\t\t\ttitle: metricName,\n\t\t\t\ttype: plotConfig.axisScales.y,\n\t\t\t\tshowgrid: true,\n\t\t\t},\n\t\t\tmargin: PLOTLY_LAYOUT_MARGIN,\n\t\t\twidth: layout.width - SETTINGS_WIDTH_PX,\n\t\t\theight: layout.height - PLOT_BOTTOM_MARGIN_PX,\n\t\t};\n\t\n\t\t// Store layout\n\t\tPLOTLY_LAYOUTS[metricName] = plotly_layout;\n\t\n\t\t// To newPlot, pass copy, don't reference\n\t\tPlotly.newPlot(plotDiv_id, [], JSON.parse(JSON.stringify(plotly_layout)));\n\t\n\t\t// Add settings menu items\n\t\tthis.createAxisToggles(metricName);\n\t\tthis.createSmoothingInput(metricName);\n\t\n\t\t// Make draggable\n\t\tLAYOUT_MANAGER.makeElementDraggable(document.getElementById(plotContainer_id));\n\t}\n\n\tasync createAllPlots(\n\t\torigin_x = 50,\n\t\torigin_y = 150,\n\t) {\n\t\tconst metrics = DATA_MANAGER.metricNames;\n\t\tlet n_metrics_counter = 0;\n\n\t\tmetrics.forEach(metricName => {\n\t\t\tn_metrics_counter += 1;\n\t\t\tconsole.log(`creating plot ${n_metrics_counter} for ${metricName}`);\n\t\t\tthis.createPlot(metricName);\n\t\t});\n\t}\n\n    async updatePlot(metricName) {\n\t\t// get and set settings & config\n        const plotInfo = this.plots[metricName];\n\t\tconst plotConfig = await LAYOUT_MANAGER.getPlotConfig(metricName);\n        if (!plotInfo) {\n            console.error(`Plot for metric ${metricName} not found.`);\n            return;\n        }\n\n\t\t// get data\n\t\t// data manager will handle reloading the data, if necessary\n\t\tvar traces = [];\n\t\tfor (const runId in DATA_MANAGER.allRuns) {\n\t\t\tconst run = DATA_MANAGER.allRuns[runId];\n\t\t\tconst run_syllabic_id = run.meta.syllabic_id;\n\n\t\t\tconst [x_vals, y_vals] = run.pairMetrics(DEFAULT_XUNITS, metricName);\n\t\t\t\n\t\t\t// Apply smoothing based on the selected method and span\n\t\t\tlet smoothedYVals = RunData.smoothData(y_vals, plotConfig.smoothing_span, plotConfig.smoothing_method);\n\t\t\t\n\t\t\tconst trace = {\n\t\t\t\tx: x_vals,\n\t\t\t\ty: smoothedYVals,\n\t\t\t\tmode: 'lines',\n\t\t\t\tline: plotConfig.smoothing_span ? { shape: 'spline' } : {},\n\t\t\t\tname: run_syllabic_id,\n\t\t\t};\n\t\t\ttraces.push(trace);\n\t\t}\n\t\t\n\t\t// Update the layout properties\n\t\tPLOTLY_LAYOUTS[metricName].xaxis.type = plotConfig.axisScales.x;\n\t\tPLOTLY_LAYOUTS[metricName].yaxis.type = plotConfig.axisScales.y;\n\t\tPLOTLY_LAYOUTS[metricName].uirevision = metricName;\n\n        // Update Plotly plot\n        Plotly.react(\n\t\t\tplotInfo.plotID, \n\t\t\ttraces,\n\t\t\tJSON.parse(JSON.stringify(PLOTLY_LAYOUTS[metricName])),\n\t\t);\n    }\n\n\tasync populateAllPlots() {\n\t\t// for each metric\n\t\tfor (const metricName of DATA_MANAGER.metricNames) {\n\t\t\tthis.updatePlot(metricName);\n\t\t}\n\t}\n\n    updateAxisScale(metricName, axis, scale) {\n\t\t// get plot info\n\t\tconst plotInfo = this.plots[metricName];\n\t\tif (!plotInfo) {\n\t\t\tconsole.error(`Plot for metric ${metricName} not found.`);\n\t\t\treturn;\n\t\t}\n\n\t\t// Update scale in settings\n\t\tconst plotConfig = LAYOUT_MANAGER.plot_configs[metricName];\n\t\tplotConfig.axisScales[axis] = scale;\n\n        // Reflect change in Plotly plot\n        Plotly.relayout(\n\t\t\tplotInfo.plotID, \n\t\t\t{ \n\t\t\t\t[`${axis}axis`]: { type: scale },\n\t\t\t\tuirevision: metricName,\n\t\t\t},\t\n\t\t);\n    }\n\n\n\tcreateAxisToggles(metricName) {\n\t\tconst plotSettingsId = this.plots[metricName].settingsID;\n\t\tconst plotDivId = this.plots[metricName].plotID;\n\t\tconst plotSettings = document.getElementById(plotSettingsId);\n\t\t\n\t\t['x', 'y'].forEach(axis => {\n\t\t\tconst toggleId = `${plotDivId}-${axis}Toggle`;\n\t\t\tconst toggleHtml = `\n\t\t\t\t<div class=\"axis-toggle-container\" style=\"display: block;\">\n\t\t\t\t\t<label for=\"${toggleId}\" style=\"display: block;\">${axis.toUpperCase()} Scale</label>\n\t\t\t\t\t<div style=\"display: flex; align-items: center;\">\n\t\t\t\t\t\t<i data-feather=\"arrow-up-right\">lin</i>\n\t\t\t\t\t\t<label class=\"switch\">\n\t\t\t\t\t\t\t<input type=\"checkbox\" id=\"${toggleId}\">\n\t\t\t\t\t\t\t<span class=\"slider round\"></span>\n\t\t\t\t\t\t</label>\n\t\t\t\t\t\t<i data-feather=\"corner-right-up\">log</i>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t`;\n\t\n\t\t\tconst toggleDiv = document.createElement('div');\n\t\t\ttoggleDiv.innerHTML = toggleHtml.trim();\n\t\t\tplotSettings.appendChild(toggleDiv);\t\t\t\n\t\n\t\t\tconst input = document.getElementById(toggleId);\n\t\t\tinput.checked = LAYOUT_MANAGER.plot_configs[metricName].axisScales[axis] === 'log';\n\t\t\tinput.onchange = () => {\n\t\t\t\tconst scale = input.checked ? 'log' : 'linear';\n\t\t\t\tthis.updateAxisScale(metricName, axis, scale);\n\t\t\t};\n\t\n\t\t});\n\t}\n\n\tasync createSmoothingInput(metricName) {\n\t\t// get the div ids\n\t\tconst plotDivId = this.plots[metricName].plotID;\n\t\tconst plotSettingsId = this.plots[metricName].settingsID;\n\n\t\t// Define the smoothing methods\n\t\tconst smoothingMethods = ['SMA', 'EMA', 'Gaussian'];\n\t\t\n\t\t// Create the HTML string for the smoothing input container\n\t\tconst smoothSettingHtml = `\n\t\t\t<div class=\"smoothing-input-container no-drag\" style=\"display: block; margin-top: 10px; border: 1px solid grey; border-radius: 3px;\">\n\t\t\t\t<label for=\"smoothingInput-${plotDivId}\" style=\"font-weight: bold;\">Smooth:</label><br>\n\t\t\t\t<label for=\"smoothingMethodSelect-${plotDivId}\">Method</label><br>\n\t\t\t\t<select class=\"no-drag\" id=\"smoothingMethodSelect-${plotDivId}\" style=\"width: 6em;\">\n\t\t\t\t\t${smoothingMethods.map(method => `<option value=\"${method}\">${method}</option>`).join('')}\n\t\t\t\t</select><br>\n\t\t\t\t<label for=\"smoothingInput-${plotDivId}\">Span</label><br>\n\t\t\t\t<input class=\"no-drag\" type=\"number\" min=\"0\" max=\"1000\" value=\"0\" id=\"smoothingInput-${plotDivId}\" style=\"width: 4.2em;\">\n\t\t\t</div>\n\t\t`;\n\t\n\t\t// Create a container for the smoothing input\n\t\tconst smoothSettingContainer = document.createElement('div');\n\t\tsmoothSettingContainer.innerHTML = smoothSettingHtml.trim();\n\t\n\t\t// Append the input container to the plot settings\n\t\tconst plotSettings = document.getElementById(plotSettingsId);\n\t\tplotSettings.appendChild(smoothSettingContainer);\n\t\n\t\t// Get references to the input elements\n\t\tconst spanInput = document.getElementById(`smoothingInput-${plotDivId}`);\n\t\tconst smoothingMethodSelect = document.getElementById(`smoothingMethodSelect-${plotDivId}`);\n\t\n\t\t// Set values to those from plot_configs\n\t\tspanInput.value = LAYOUT_MANAGER.plot_configs[metricName].smoothing_span;\n\t\tsmoothingMethodSelect.value = LAYOUT_MANAGER.plot_configs[metricName].smoothing_method;\n\t\n\t\t// On change, modify the plot config and call updatePlot\n\t\tspanInput.onchange = () => {\n\t\t\tLAYOUT_MANAGER.plot_configs[metricName].smoothing_span = parseInt(spanInput.value);\n\t\t\tthis.updatePlot(metricName);\n\t\t};\n\t\tsmoothingMethodSelect.onchange = () => {\n\t\t\tLAYOUT_MANAGER.plot_configs[metricName].smoothing_method = smoothingMethodSelect.value;\n\t\t\tthis.updatePlot(metricName); // Update the plot when smoothing method changes\n\t\t};\n\t}\n}\n\nlet PLOT_MANAGER = new PlotManager();\n\n\n\n/*\n##     ## ########    ###    ########  ######## ########\n##     ## ##         ## ##   ##     ## ##       ##     ##\n##     ## ##        ##   ##  ##     ## ##       ##     ##\n######### ######   ##     ## ##     ## ######   ########\n##     ## ##       ######### ##     ## ##       ##   ##\n##     ## ##       ##     ## ##     ## ##       ##    ##\n##     ## ######## ##     ## ########  ######## ##     ##\n*/\n\nasync function headerButtons() {\n\t// get the project name, set the header\n\tconst projectH1 = document.getElementById('projectH1');\n\tprojectH1.textContent = DATA_MANAGER.projectName + ' trnbl Dashboard';\n\tconst gridSnapCheckbox = document.getElementById('gridSnapCheckbox');\n\n\t// set up grid snap checkbox\n\tgridSnapCheckbox.checked = LAYOUT_MANAGER.do_snap;\n\tgridSnapCheckbox.addEventListener('change', function() {\n\t\tLAYOUT_MANAGER.updateSnap(gridSnapCheckbox.checked);\n\t});\n\n\t// save layout to local storage\n\tdocument.getElementById('saveLayoutButton').addEventListener(\n\t\t'click',\n\t\tasync () => {\n\t\t\tawait LAYOUT_MANAGER.saveLayout();\n\t\t}\n\t);\n\n\t// download layout as json\n\tdocument.getElementById('downloadLayoutButton').addEventListener(\n\t\t'click',\n\t\tasync () => {\n\t\t\tconst layoutKey = LAYOUT_MANAGER.get_local_storage_key();\n\t\t\tconst layout_json = JSON.stringify(LAYOUT_MANAGER, null, '\\t');\n\t\t\tconst blob = new Blob([layout_json], { type: 'application/json' });\n\t\t\tconst url = URL.createObjectURL(blob);\n\t\t\tconst a = document.createElement('a');\n\t\t\ta.href = url;\n\t\t\ta.download = layoutKey + '.json';\n\t\t\tdocument.body.appendChild(a);\n\t\t\ta.click();\n\t\t\ta.remove();\n\t\t\tURL.revokeObjectURL(url);\n\t\t}\n\t);\n\n\t// reset layout to default\n\tdocument.getElementById('resetLayoutButton').addEventListener(\n\t\t'click',\n\t\tasync () => {\n\t\t\t// delete\n\t\t\tconst layoutKey = LAYOUT_MANAGER.get_local_storage_key();\n\t\t\tIO_MANAGER.deleteJsonLocal(layoutKey);\n\t\t\t// reload page\n\t\t\tlocation.reload();\n\t\t\tcreateNotification('Layout resetting...', 'info');\n\t\t}\n\t);\n\t\n\t// refresh data\n\tdocument.getElementById('refreshButton').addEventListener(\n\t\t'click',\n\t\tasync () => {\n\t\t\tcreateNotification('Checking for data updates...', 'info');\n\t\t\tconst dataUpdated = await DATA_MANAGER.refreshData();\n\t\t\tif (dataUpdated) {\n\t\t\t\tconst updatedRunsInfo = DATA_MANAGER.getUpdatedRunsInfo();\n\t\t\t\t\n\t\t\t\t// Update plots\n\t\t\t\tawait PLOT_MANAGER.populateAllPlots();\n\t\t\t\t\n\t\t\t\t// Update table\n\t\t\t\tconst gridApi = GRID_API.getGridApi();\n\t\t\t\tgridApi.setRowData(DATA_MANAGER.summaryManifest);\n\t\t\t\t\n\t\t\t\t// Detailed notification\n\t\t\t\tif (updatedRunsInfo.count > 0) {\n\t\t\t\t\tif (updatedRunsInfo.count < 3) {\n\t\t\t\t\t\tcreateNotification(`Data refreshed successfully. ${updatedRunsInfo.count} run(s) updated: ${updatedRunsInfo.runs.join(', ')}`, 'info');\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcreateNotification(`Data refreshed successfully. ${updatedRunsInfo.count} run(s) updated.`, 'info');\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Notify about each updated run\n\t\t\t\t\tupdatedRunsInfo.runs.forEach(runId => {\n\t\t\t\t\t\tcreateNotification(`Run ${runId} was updated`, 'info');\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tcreateNotification('Manifest updated, but no individual runs were changed', 'info');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcreateNotification('No new data updates found', 'info');\n\t\t\t}\n\t\t}\n\t);\n\n\t// reset colum state of table\n\tdocument.getElementById('resetColumnStateButton').addEventListener(\n\t\t'click',\n\t\tasync () => {\n\t\t\tGRID_API.resetColumnState();\n\t\t}\n\t);\n}\n\nfunction createNotification(message, type = 'info') {\n    const log_str = `[${type}]: ${message}`;\n    // print to console\n    switch (type) {\n        case 'info':\n            console.log(log_str);\n            break;\n        case 'warning':\n            console.warn(log_str);\n            break;\n        case 'error':\n            console.error(log_str);\n            break;\n        default:\n            console.log(log_str);\n    }\n\n    // create notification div\n    const notificationDiv = document.createElement('div');\n    notificationDiv.textContent = message;\n    notificationDiv.style.cssText = `\n        position: fixed;\n        top: 10px;\n        right: 10px;\n        padding: 10px;\n        border-radius: 5px;\n        background-color: ${NOTIFICATION_COLORS[type]};\n        border: 1px solid ${NOTIFICATION_BORDER_COLORS[type]};\n        box-shadow: 0 2px 5px rgba(0,0,0,0.2);\n        transition: transform 0.3s ease-out, opacity 0.3s ease-out;\n        z-index: 1000;\n        opacity: 0;  // Start with 0 opacity for fade-in effect\n    `;\n    \n    // Function to update positions of all notifications\n    function updateNotificationPositions() {\n        const notifications = document.querySelectorAll('.notification');\n        let currentTop = 10;\n        notifications.forEach((notification) => {\n            notification.style.transform = `translateY(${currentTop}px)`;\n            currentTop += notification.offsetHeight + 10; // 10px gap between notifications\n        });\n    }\n\n    // Add a class for easier selection\n    notificationDiv.classList.add('notification');\n\n    // Insert the new notification at the top\n    const firstNotification = document.querySelector('.notification');\n    if (firstNotification) {\n        document.body.insertBefore(notificationDiv, firstNotification);\n    } else {\n        document.body.appendChild(notificationDiv);\n    }\n\n    // Trigger reflow to ensure the initial state is applied before changing opacity\n    notificationDiv.offsetHeight;\n\n    // Fade in the notification\n    notificationDiv.style.opacity = '1';\n\n    // Update positions after a short delay to allow for DOM update\n    setTimeout(updateNotificationPositions, 10);\n\n    // Remove the notification after 3 seconds\n    setTimeout(() => {\n        notificationDiv.style.opacity = '0';\n        notificationDiv.style.transform += ' translateX(100%)';\n        setTimeout(() => {\n            notificationDiv.remove();\n            updateNotificationPositions();\n        }, 300); // Match this with the CSS transition time\n    }, 3000);\n}\n\n\n/*\n########    ###    ########  ##       ########\n   ##      ## ##   ##     ## ##       ##\n   ##     ##   ##  ##     ## ##       ##\n   ##    ##     ## ########  ##       ######\n   ##    ######### ##     ## ##       ##\n   ##    ##     ## ##     ## ##       ##\n   ##    ##     ## ########  ######## ########\n*/\n\n\nfunction isISODate(value) {\n    // This regex matches ISO 8601 date strings with optional fractional seconds and timezone information\n    const dateRegex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(.\\d+)?(Z|[+-]\\d{2}:\\d{2})?$/;\n    return dateRegex.test(value);\n}\n\n// fancy cell rendering -- hover/copy/open the data, make it emojis if its too long\nfunction fancyCellRenderer(params) {\n\t// check if params.value is undefined\n\tvar value;\n\tif (params.value === undefined) {\n\t\treturn div;\n\t}\n\telse {\n\t\tvalue = params.value;\n\t}\n\t// Create the div element\n\tvar div = document.createElement('div');\n\t// set content\n\tdiv.title = value;\n\tdiv.textContent = value;\n\tdiv.style.cursor = 'pointer';\n\t// if its too long, make it emojis\n\tif (value !== null) {\n\t\t// if object, convert to string\n\t\tif (typeof value === 'object') {\n\t\t\tvalue = JSON.stringify(value, null, 4);\n\t\t}\n\t\tif (value.length > 50) {\n\t\t\tdiv.title = value;\n\t\t\tdiv.innerHTML = feather.icons[\"mouse-pointer\"].toSvg() + feather.icons[\"copy\"].toSvg();\n\t\t\tdiv.style.cssText = 'font-size: 20px; display: flex; justify-content: center; align-items: center; background-color: #f4f4f4; border: 1px solid #d4d4d4; border-radius: 5px; height: 30px; width: 60px;';\n\t\t}\n\t}\n\n\t// Add click event listener to copy text to the clipboard\n\tdiv.onclick = function() {\n\t\tnavigator.clipboard.writeText(value).then(function() {\n\t\t\tconsole.log('Successfully copied to clipboard');\n\t\t}).catch(function(err) {\n\t\t\tconsole.error('Could not copy text to clipboard: ', err);\n\t\t});\n\t};\n\n\t// on right click, open a new plain text tab whose contents are the cell's value\n\tdiv.oncontextmenu = function() {\n\t\tconst newWindow = window.open('', '_blank');\n\t\t// set the contents of the new window to the cell's value\n\t\tnewWindow.document.write('<pre>' + value + '</pre>');\n\t\t// set the title of the page to the rows \"name.default_alias\" and the column's header\n\t\tnewWindow.document.title = params.node.data['id.run'] + ' : ' + params.colDef.headerName; // TODO: page has \"undefined\" in title\n\t\tnewWindow.document.close();\n\t};\n\n\t// Return the div as the cell's DOM\n\treturn div;\n}\n\n\nfunction createColumnDefs(summaryManifest) {\n    var columnDefs = [\n        {\n            headerName: 'view/hide',\n            field: 'selected',\n            width: 30,\n            checkboxSelection: true,\n            headerCheckboxSelection: true,\n            headerCheckboxSelectionFilteredOnly: true,\n        },\n    ];\n\n\t// date filter\n\tconst date_def = {\n\t\tfilter: 'agDateColumnFilter',\n\t\tfilterParams: {\n\t\t\tcomparator: function(filterValue, cellValue) {\n\t\t\t\t// Assuming cellValue is an ISO date string\n\t\t\t\tconst cellDate = new Date(cellValue);\n\t\t\t\tconst filterDate = new Date(filterValue);\n\t\t\t\tif (cellDate < filterDate) {\n\t\t\t\t\treturn -1;\n\t\t\t\t} else if (cellDate > filterDate) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t},\n\t\t\t// Disable the use of the browser-provided date picker for this filter\n\t\t\tbrowserDatePicker: false,\n\t\t\t// Add the inRange filter option\n\t\t\tinRangeInclusive: true,\n\t\t}\n\t}\n\n\n    // Define column groups\n    const columnGroupDefs = [\n        {\n            headerName: 'Name',\n            children: [\n                { field: 'id.syllabic', headerName: 'Syllabic ID', columnGroupShow: null },\n                { field: 'id.run', headerName: 'Full Run ID', columnGroupShow: 'open' },\n            ],\n\t\t\tmarryChildren: true,\n        },\n        {\n            headerName: 'Timing',\n            children: [\n                { field: 'timing.start', headerName: 'Start', columnGroupShow: null, ...date_def },\n                { field: 'timing.final', headerName: 'End', columnGroupShow: 'open', ...date_def },\n                { field: 'timing.duration', headerName: 'Duration (ms)', columnGroupShow: 'open', },\n            ],\n\t\t\tmarryChildren: true,\n        },\n        {\n            headerName: 'Final Metrics',\n            children: [],\n        },\n        {\n            headerName: 'Config',\n            children: [\n                {\n                    field: 'config',\n                    headerName: 'Config',\n                    // width: 50, // TODO: this width is broken\n\t\t\t\t\tcellRenderer: fancyCellRenderer,\n                },\n            ],\n\t\t\tmarryChildren: true,\n        },\n    ];\n\n    // Dynamically add final metric columns\n    const finalMetricKeys = new Set();\n    summaryManifest.forEach(item => {\n        Object.keys(item.final_metrics).forEach(key => finalMetricKeys.add(key));\n    });\n\tvar final_metrics_counter = 0;\n    finalMetricKeys.forEach(key => {\n        columnGroupDefs[2].children.push({\n\t\t\tfield: `final_metrics.${key}`, \n\t\t\theaderName: key,\n\t\t\tcolumnGroupShow: final_metrics_counter === 1 ? null : 'open',\n\t\t});\n\t\tfinal_metrics_counter += 1;\n    });\n\n    // Add column group definitions to the main column definitions\n    columnDefs = columnDefs.concat(columnGroupDefs);\n\n    return columnDefs;\n}\n\nfunction adjustTableHeight(table) {\n\t// Adjust the height of the table container\n\tconst gridHeight = table.querySelector('.ag-center-cols-viewport').offsetHeight;\n\tconst headerHeight = table.querySelector('.ag-header').offsetHeight;\n\tconst paginationHeight = table.querySelector('.ag-paging-panel').offsetHeight;\n\tconst tableMinHeight = gridHeight + headerHeight + paginationHeight + 50;\n\ttable.style.minHeight = `${tableMinHeight}px`;\n}\n\n\nfunction createRunsManifestTable(summaryManifest) {\n\t// create plot container\n\tconst runsManifestTable = document.createElement('div');\n\trunsManifestTable.id = 'runsManifest';\n\trunsManifestTable.classList.add('runsManifestBox', 'ag-theme-alpine');\n\tdocument.getElementById('rootContainerDiv').appendChild(runsManifestTable);\n\n\t// load layout\n\tconst layout = LAYOUT_MANAGER.layout[runsManifestTable.id];\n\tif (layout) {\n\t\trunsManifestTable.style.cssText = `position: absolute; width: ${layout.width}px; height: ${layout.height}px; left: ${layout.x}px; top: ${layout.y}px; margin-bottom: 20px; ${DEFAULT_STYLE}`;\n\t}\n\t// make draggable\n\tLAYOUT_MANAGER.makeElementDraggable(runsManifestTable);\n\n\t// create the grid options\n\tconst gridOptions = {\n        columnDefs: createColumnDefs(summaryManifest),\n        rowData: summaryManifest,\n        pagination: true,\n\t\tenableCellTextSelection: true,\n\t\tenableBrowserTooltips: true,\n\t\trowSelection: 'multiple',\n\t\t// customize pagination\n\t\tpagination: true,\n\t\tpaginationPageSize: 10,\n\t\tpaginationPageSizeSelector: [1, 2, 5, 10, 25, 50, 100, 500, 1000],\n\t\tdefaultColDef: {\n\t\t\tresizable: true,\n\t\t\tfilter: true,\n\t\t\t// always show the floating filter\n\t\t\tfloatingFilter: true,\n\t\t\t// disable filter hamburger menu (for space)\n\t\t\tmenuTabs: [],\n\t\t},\n\t\tdomLayout: 'autoHeight',\n\t\tonFirstDataRendered: function(params) {\n            adjustTableHeight(runsManifestTable);\n        },\n        onPaginationChanged: function(params) {\n            adjustTableHeight(runsManifestTable);\n        },\n\t\tinitialState: LAYOUT_MANAGER.grid_state,\n    };\n\n\t// create the ag-Grid table, api to global\n\t// api is used in LayoutManager.updateGridState\n\tGRID_API = agGrid.createGrid(runsManifestTable, gridOptions);\n\n}\n\n\n\n\n/*\n#### ##    ## #### ########\n ##  ###   ##  ##     ##\n ##  ####  ##  ##     ##\n ##  ## ## ##  ##     ##\n ##  ##  ####  ##     ##\n ##  ##   ###  ##     ##\n#### ##    ## ####    ##\n*/\n\n\nasync function init() {\n\t// load basic data\n\t// await loadManifestAndMetrics();\n\tawait DATA_MANAGER.loadManifest();\n\t// layout stuff\n\tLAYOUT_MANAGER = new LayoutManager(DATA_MANAGER.projectName);\n\tLAYOUT_MANAGER.loadLayout(do_update = false);\n\t// set up header and buttons\n\tawait headerButtons();\n\t// create empty plots\n\tawait PLOT_MANAGER.createAllPlots();\n\t// load data\n\tawait DATA_MANAGER.loadRuns();\n\t// populate table\n\tawait createRunsManifestTable(DATA_MANAGER.summaryManifest);\n\t// populate plots\n\tawait PLOT_MANAGER.populateAllPlots();\n\t// load layout\n\t// LAYOUT_MANAGER.updateAllLayouts();\n\t// update draggables\n\t// await updateDraggableSnapIntervals();\n\n\t// feather icons\n\ttry {\n\t\t// replace the icons\n\t\tfeather.replace();\n\t\t// if no errors, look for any <i> tags with class `data-feather` and remove the text\n\t\tconst featherIcons = document.querySelectorAll('i[data-feather]');\n\t\tfeatherIcons.forEach(icon => {\n\t\t\ticon.innerHTML = '';\n\t\t});\n\t}\n\tcatch (e) {\n\t\tconsole.error('Feather icons not found');\n\t\tdisplayNotification('Feather icons not found, keeping text fallback', 'error');\n\t}\n\tconsole.log('init complete');\n\n\tfeather.replace();\n}\n</script></head>\n<body>\n<header id=\"mainHeader\">\n<h1 id=\"projectH1\">trnbl Dashboard</h1>\n<button class=\"headerButton\" id=\"refreshButton\">\n<i data-feather=\"refresh-cw\"></i><i data-feather=\"bar-chart-2\"></i>\n            Refresh Data\n        </button>\n<button class=\"headerButton\" id=\"saveLayoutButton\">\n<i data-feather=\"save\"></i><i data-feather=\"layout\"></i>\n            Save Current Layout\n        </button>\n<button class=\"headerButton\" id=\"resetLayoutButton\">\n<i data-feather=\"refresh-ccw\"></i><i data-feather=\"layout\"></i>\n            Reset Layout</button>\n<button class=\"headerButton\" id=\"downloadLayoutButton\">\n<i data-feather=\"download\"></i><i data-feather=\"layout\"></i>\n            Download Current Layout\n        </button>\n<div class=\"headerButton\">\n<input id=\"gridSnapCheckbox\" type=\"checkbox\"/>\n<label for=\"gridSnapCheckbox\">\n<i data-feather=\"grid\"></i> Grid Snap\n            </label>\n</div>\n<button class=\"headerButton\" id=\"resetColumnStateButton\">\n<i data-feather=\"refresh-ccw\"></i><i data-feather=\"columns\"></i>\n            Reset Column State\n        </button>\n<hr/>\n</header>\n<div class=\"rootContainer\" id=\"rootContainerDiv\">\n<div id=\"invisHbar\" style=\"width: 100em; height: 100em;\"></div>\n</div>\n<script>\n        document.addEventListener('DOMContentLoaded', init);\n    </script>\n</body>\n</html>\n"


if __name__ == "__main__":
	print(get_html_frontend())
